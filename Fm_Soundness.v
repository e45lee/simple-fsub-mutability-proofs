(** Type-safety proofs for Fm.

    Authors: Edward Lee and Ondrej Lhotak

    Based on work by: Brian Aydemir and Arthur Chargu\'eraud, with help from
    Aaron Bohannon, Jeffrey Vaughan, and Dimitrios Vytiniotis.

    In parentheses are given the label of the corresponding lemma in
    the appendix (informal proofs) of the POPLmark Challenge.

    Table of contents:
      - #<a href="##subtyping">Properties of subtyping</a>#
      - #<a href="##lemma_4.3">Lemma 4.3 -- normal forms and subtyping</a>#
      - #<a href="##lemma_4.3">Lemma 4.4 -- record subtyping inversion</a>#
      - #<a href="##lemma_4.3">Lemma 4.6 -- read-only record subtyping inversion</a>#
      - #<a href="##typing">Properties of typing</a>#
      - #<a href="##lemma_4.3">Lemma 4.8 -- read-only record canonical typing </a>#
      - #<a href="##preservation">Preservation</a>#
      - #<a href="##lemma_4.3">Lemma 4.5 -- record canonical forms</a>#
      - #<a href="##lemma_4.3">Lemma 4.7 -- read-only record canonical forms</a>#
      - #<a href="##progress">Progress</a># *)

Require Export Fsub.Fm_NormalForms.


(* ********************************************************************** *)
(** * #<a name="subtyping"></a># Properties of subtyping *)


(* ********************************************************************** *)
(** ** Reflexivity (1) *)

Lemma sub_reflexivity : forall E T,
  wf_env E ->
  wf_typ E T ->
  sub E T T.
Proof with eauto.
  intros E T Ok Wf.
  induction Wf...
  Case "sub_all".
    pick fresh Y and apply sub_all...
Qed.


(* ********************************************************************** *)
(** ** Weakening (2) *)

Lemma sub_weakening : forall E F G S T,
  sub (G ++ E) S T ->
  wf_env (G ++ F ++ E) ->
  sub (G ++ F ++ E) S T.
Proof with simpl_env; auto using wf_typ_weakening.
  intros E F G S T Sub Ok.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Sub; intros G Ok EQ; subst...
  Case "sub_trans_tvar".
    apply (sub_trans_tvar U)...
  Case "sub_all".
    pick fresh Y and apply sub_all...
    rewrite <- app_assoc.
    apply H0...
  Case "sub_trans".
    eapply sub_trans...
Qed.


(* ********************************************************************** *)
(** ** Narrowing and transitivity (3) *)

Definition transitivity_on Q := forall E S T,
  sub E S Q -> sub E Q T -> sub E S T.

Lemma sub_narrowing_aux : forall Q F E Z P S T,
  transitivity_on Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub E P Q ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with simpl_env; eauto using wf_typ_narrowing, wf_env_narrowing.
  intros Q F E Z P S T TransQ SsubT PsubQ.
  remember (F ++ Z ~ bind_sub Q ++ E) as G. generalize dependent F.
  induction SsubT; intros F EQ; subst...
  Case "sub_trans_tvar".
    destruct (X == Z); subst.
    SCase "X = Z".
      apply (sub_trans_tvar P); [ eauto using fresh_mid_head | ].
      apply TransQ.
      SSCase "P <: Q".
        rewrite_env (empty ++ (F ++ Z ~ bind_sub P) ++ E).
        apply sub_weakening...
      SSCase "Q <: T".
        analyze_binds_uniq H.
        injection BindsTacVal; intros; subst...
    SCase "X <> Z".
      apply (sub_trans_tvar U)...
  Case "sub_all".
    pick fresh Y and apply sub_all...
    rewrite <- app_assoc.
    apply H0...
Qed.

Lemma sub_transitivity : forall Q,
  transitivity_on Q.
Proof with simpl_env; auto.
  unfold transitivity_on.
  intros Q E S T SsubQ QsubT.
  eapply sub_trans with (T2 := Q)...
Qed.

Lemma sub_narrowing : forall Q E F Z P S T,
  sub E P Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof.
  intros.
  eapply sub_narrowing_aux; eauto.
  apply sub_transitivity.
Qed.

(* ********************************************************************** *)
(** ** Normal Forms (16) and Subtyping *)

Lemma merge_mutability_sub : forall E T m,
  wf_env E ->
  wf_typ E T ->
  sub E (typ_mut m T) (merge_mutability T m).
Proof with eauto 4 using sub_reflexivity; 
  repeat (fold merge_mutability; fold normal_form_typing).
  intros E T M WfE WfT.
  destruct M.
  dependent induction WfT; unfold merge_mutability; subst...
  eapply sub_denormalize...
  eapply sub_denormalize...
  eapply sub_denormalize... 
    simpl...
    rewrite merge_mutability_multiple...
  eapply sub_denormalize...
    simpl...
    rewrite 2 normal_form_merge_mutability_exchange...
    eapply sub_reflexivity...
    eapply wf_typ_intersect...
Qed.

Lemma sub_merge_mutability : forall E T m,
  wf_env E ->
  wf_typ E T ->
  sub E (merge_mutability T m) (typ_mut m T).
Proof with eauto 4 using sub_reflexivity; 
  repeat (fold merge_mutability; fold normal_form_typing).  
  intros E T M WfE WfT.
  destruct M.
  dependent induction WfT; unfold merge_mutability; subst...
  unshelve epose proof (IHWfT1 _) as IT1...
  unshelve epose proof (IHWfT2 _) as IT2...

  assert (sub E (typ_int (merge_mutability T1 mut_readonly) (merge_mutability T2 mut_readonly))
                (typ_mut mut_readonly T1))...
  assert (sub E (typ_int (merge_mutability T1 mut_readonly) (merge_mutability T2 mut_readonly))
                (typ_mut mut_readonly T2))...

  eapply sub_denormalize; simpl...
  rewrite 2 normal_form_merge_mutability_exchange...
  eapply sub_reflexivity...
  eapply wf_typ_intersect...
Qed.

(** #<a name="lemma_4.3"</a># Lemma 4.3: nf(T) = T under the subtyping relationship. *)
Lemma sub_normal_form_equivalent : forall E T,
  wf_env E ->
  wf_typ E T ->
  sub E T (normal_form_typing T) /\ sub E (normal_form_typing T) T.
Proof with eauto 4 using sub_narrowing, sub_reflexivity, sub_transitivity;
  repeat (try fold normal_form_typing; try fold merge_mutability).
  intros E T WfE WfT.
  dependent induction WfT; subst; try solve [split; simpl; eauto 4].
  - split...
    * econstructor... apply IHWfT1... apply IHWfT2...
    * econstructor... apply IHWfT1... apply IHWfT2...
  - split...
    * pick fresh X and apply sub_all...
      apply IHWfT...
      destruct (H0 X)...
      eapply sub_narrowing with (F := empty) (Q := T1)...
      apply IHWfT...
      rewrite <- normal_form_open_tt...
    * pick fresh X and apply sub_all...
      apply IHWfT...
      destruct (H0 X)...
      eapply sub_narrowing with (F := empty) (Q := T1)...
      rewrite  <-normal_form_open_tt...
  - split; apply sub_box; destruct IHWfT; subst...
  - split...
    * unfold normal_form_typing, merge_mutability...
      destruct (normal_form_typing T); unfold merge_mutability; destruct IHWfT; subst...
      + eapply sub_transitivity with (Q := typ_mut mut_readonly (typ_arrow t1 t2))...
        eapply sub_denormalize...
      + eapply sub_transitivity with (Q := typ_mut mut_readonly (typ_all t1 t2))...
        eapply sub_denormalize...
      + destruct m; subst...
        eapply sub_transitivity with (Q := typ_mut mut_readonly (typ_mut mut_readonly t))...      
        eapply sub_denormalize; simpl...
        rewrite merge_mutability_multiple...
        eapply sub_reflexivity...
      + assert (sub E (typ_mut mut_readonly T) (typ_mut mut_readonly (typ_int t1 t2)))...
        eapply sub_transitivity...
        eapply merge_mutability_sub...
    * unfold normal_form_typing...
      destruct (normal_form_typing T); unfold merge_mutability; destruct IHWfT; subst...
      eapply sub_transitivity with (Q := typ_mut mut_readonly (typ_int t1 t2))...
      replace (typ_int (merge_mutability t1 mut_readonly) (merge_mutability t2 mut_readonly))
        with (merge_mutability (typ_int t1 t2) mut_readonly)...
      eapply sub_merge_mutability...
  - destruct IHWfT1; subst...
    destruct IHWfT2; subst...
    split...
    * unfold normal_form_typing...
      apply sub_inter...
    * unfold normal_form_typing...
      apply sub_inter...
  - split; apply sub_record; destruct IHWfT...
Qed.

Lemma sub_normalize_left : forall E S T,
  sub E S T ->
  sub E (normal_form_typing S) T.
Proof with eauto.
  intros.
  destruct (sub_normal_form_equivalent E S)...
Qed.

Lemma sub_normalize_right : forall E S T,
  sub E S T ->
  sub E S (normal_form_typing T).
Proof with eauto.
  intros.
  destruct (sub_normal_form_equivalent E T)...
Qed.
#[export] Hint Resolve sub_normalize_left sub_normalize_right : core.

Lemma sub_in_intersection : forall E S T T',
  in_intersection T T' ->
  sub E S T' ->
  sub E S T.
Proof with eauto using sub_reflexivity.
  intros *  Int Sub.
  eapply sub_transitivity...
  assert (wf_typ E T')...
  assert (wf_env E)...
  clear Sub.
  dependent induction Int; subst...
  - eapply sub_transitivity with (Q := L)...
  - eapply sub_transitivity with (Q := R)...
Qed.
#[export] Hint Resolve sub_in_intersection : core.


Lemma sub_through_normalization : forall E T U,
  sub E (normal_form_typing T) (normal_form_typing U) ->
  wf_typ E T ->
  wf_typ E U ->
  sub E T U.
Proof with eauto using sub_reflexivity.
  intros * Sub WfT WfU.
  eapply sub_transitivity with (Q := normal_form_typing T)...
Qed.
#[export] Hint Resolve sub_through_normalization : core.


(* ********************************************************************** *)
(** ** Type substitution preserves subtyping (10) *)
Lemma merge_mutability_subst_tt : forall Z P T m,
  normal_form_typing (merge_mutability (subst_tt Z P T) m) =
  normal_form_typing (subst_tt Z P (merge_mutability T m)).
Proof with simpl in *; autorewrite with core in *; eauto; repeat 
  (fold merge_mutability in *; fold normal_form_typing in *);
  try solve [f_equal; eauto].
  intros.
  destruct m.
  dependent induction T...
  destruct (a == Z)...
  rewrite normal_form_merge_mutability_exchange...
Qed.

Lemma normal_form_subst_tt : forall Z P T,
  normal_form_typing (subst_tt Z P T) =
  normal_form_typing (subst_tt Z P (normal_form_typing T)).
Proof with simpl in *; eauto; repeat 
  (fold merge_mutability in *; fold normal_form_typing in *);
  try solve [f_equal; eauto].
  intros.
  dependent induction T...
  rewrite IHT.
  rewrite <- normal_form_merge_mutability_exchange.
  rewrite <- merge_mutability_subst_tt...
Qed.

Lemma sub_through_subst_tt : forall Q E F Z S T P,
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub E P Q ->
  sub (map (subst_tb Z P) F ++ E) (subst_tt Z P S) (subst_tt Z P T).
Proof with
      simpl_env;
      eauto 4 using wf_typ_subst_tb, wf_env_subst_tb, wf_typ_weaken_head,
        sub_reflexivity.
  intros Q E F Z S T P SsubT PsubQ.
  remember (F ++ Z ~ bind_sub Q ++ E) as G.
  generalize dependent F.
  induction SsubT; intros G EQ; subst; simpl subst_tt...
  Case "sub_top".
    apply sub_top...
  Case "sub_refl_tvar".
    destruct (X == Z); subst.
    SCase "X = Z".
      apply sub_reflexivity...
    SCase "X <> Z".
      apply sub_reflexivity...
      inversion H0; subst.
      analyze_binds H3...
      apply (wf_typ_var (subst_tt Z P U))...
  Case "sub_trans_tvar".
    destruct (X == Z); subst.
    SCase "X = Z".
      apply (sub_transitivity Q).
      SSCase "left branch".
        rewrite_env (empty ++ map (subst_tb Z P) G ++ E).
        apply sub_weakening...
      SSCase "right branch".
        rewrite (subst_tt_fresh Z P Q).
          analyze_binds_uniq H.
            inversion BindsTacVal; subst...
          apply (notin_fv_wf E); eauto using fresh_mid_tail.
    SCase "X <> Z".
      apply (sub_trans_tvar (subst_tt Z P U))...
      rewrite (map_subst_tb_id E Z P);
        [ | auto | eapply fresh_mid_tail; eauto ].
      analyze_binds H...
  Case "sub_all".
    pick fresh X and apply sub_all...
    rewrite subst_tt_open_tt_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env (map (subst_tb Z P) (X ~ bind_sub T1 ++ G) ++ E).
    apply H0...
  Case "sub_inter_left".
    apply sub_inter_left...
  Case "sub_inter_right".
    apply sub_inter_right...
  Case "sub_denormalize".
    eapply sub_transitivity with
      (normal_form_typing (subst_tt Z P T1))...
    eapply sub_normalize_right...
    eapply sub_reflexivity...
    eapply sub_transitivity with
      (normal_form_typing (subst_tt Z P T2))...
    rewrite (normal_form_subst_tt Z P T1).
    rewrite (normal_form_subst_tt Z P T2).
    eapply sub_transitivity with
      (subst_tt Z P (normal_form_typing T1))...
    eapply sub_normalize_left...
    eapply sub_reflexivity...
      eapply wf_typ_subst_tb...
    eapply sub_normalize_left...
    eapply sub_reflexivity...
Qed.


(* ********************************************************************** *)
(** * #<a name="typing"></a># Properties of typing *)


(* ********************************************************************** *)
(** ** Weakening (5) *)

Lemma typing_weakening : forall E F G R e T,
  typing (G ++ E) R e T ->
  wf_env (G ++ F ++ E) ->
  typing (G ++ F ++ E) R e T
with typing_record_weakening : forall E F G R r T,
  typing_record_comp (G ++ E) R r T ->
  wf_env (G ++ F ++ E) ->
  typing_record_comp (G ++ F ++ E) R r T.
Proof with simpl_env;
           eauto using wf_typ_weakening,
                       wf_sig_weakening,
                       wf_typ_from_wf_env_typ,
                       wf_typ_from_wf_env_sub,
                       sub_weakening.
------
  clear typing_weakening.
  intros E F G R e T Typ.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Typ; intros G EQ Ok; subst...
  Case "typing_abs".
    pick fresh x and apply typing_abs; try solve [eauto using wf_sig_weakening].
    lapply (H0 x); [intros K | auto].
    rewrite <- app_assoc.
    apply (H1 x)...
  Case "typing_tabs".
    pick fresh X and apply typing_tabs; try solve [eauto using wf_sig_weakening].
    lapply (H0 X); [intros K | auto].
    rewrite <- app_assoc.
    apply (H1 X)...
  Case "typing_let".
    pick fresh x and apply typing_let...
    lapply (H1 x); [intros K | auto].
    rewrite <- app_assoc.
    apply H1...
------
  clear typing_record_weakening.
  intros E F G R r T Typ.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Typ; intros G EQ Ok; subst...
Qed.

Lemma typing_weakening_sig : forall E R U S e T,
  typing E (S ++ R) e T ->
  wf_sig E (S ++ U ++ R) ->
  typing E (S ++ U ++ R) e T
with typing_record_weakening_sig : forall E R U S r T,
  typing_record_comp E (S ++ R) r T ->
  wf_sig E (S ++ U ++ R) ->
  typing_record_comp E (S ++ U ++ R) r T.
Proof with simpl_sig; eauto using wf_sig_weaken_head.
------
  clear typing_weakening_sig.
  intros E R U S e T Typ.
  remember (S ++ R) as H.
  generalize dependent S.
  induction Typ; intros S' EQ Ok; subst...
  Case "typing_abs".
    pick fresh x and apply typing_abs; try assumption.
    lapply (H0 x); [intros K | auto].
    apply (H1 x)...
  Case "typing_tabs".
    pick fresh X and apply typing_tabs; try assumption.
    lapply (H0 X); [intros K | auto].
    apply (H1 X)...
  Case "typing_let".
    pick fresh x and apply typing_let...
------
  clear typing_record_weakening_sig.
  intros E R U S r T Typ.
  remember (S ++ R) as H.
  generalize dependent S.
  induction Typ; intros S' EQ Ok; subst...
Qed.

Lemma typing_weakening_sig_head : forall E R R' e T,
  typing E R e T ->
  wf_sig E (R' ++ R) ->
  typing E (R' ++ R) e T.
Proof with simpl_sig; eauto.
  intros E R R' e T Typ.
  rewrite_sig (sempty ++ R' ++ R).
  intros OK. apply typing_weakening_sig...
Qed.

Lemma typing_record_weakening_sig_head : forall E R R' r T,
  typing_record_comp E R r T ->
  wf_sig E (R' ++ R) ->
  typing_record_comp E (R' ++ R) r T.
Proof with simpl_sig; eauto.
  intros E R R' r T Typ.
  rewrite_sig (sempty ++ R' ++ R).
  intros OK. apply typing_record_weakening_sig...
Qed.

(* ********************************************************************** *)
(** ** Strengthening (6) *)

Lemma sub_strengthening : forall x U E F S T,
  sub (F ++ x ~ bind_typ U ++ E) S T ->
  sub (F ++ E) S T.
Proof with eauto using wf_typ_strengthening, wf_env_strengthening.
  intros x U E F S T SsubT.
  remember (F ++ x ~ bind_typ U ++ E) as E'.
  generalize dependent F.
  induction SsubT; intros F EQ; subst...
  Case "sub_trans_tvar".
    apply (sub_trans_tvar U0)...
    analyze_binds H...
  Case "sub_all".
    pick fresh X and apply sub_all...
    rewrite <- app_assoc.
    apply H0...
Qed.


(************************************************************************ *)
(** ** Narrowing for typing (7) *)

Lemma typing_narrowing : forall Q E F X P R e T,
  sub E P Q ->
  typing (F ++ X ~ bind_sub Q ++ E) R e T ->
  typing (F ++ X ~ bind_sub P ++ E) R e T
with typing_record_narrowing : forall Q E F X P R r T,
  sub E P Q ->
  typing_record_comp (F ++ X ~ bind_sub Q ++ E) R r T ->
  typing_record_comp (F ++ X ~ bind_sub P ++ E) R r T.
Proof with eauto 6 using 
  wf_env_narrowing, wf_typ_narrowing, sub_narrowing, wf_sig_narrowing.
------
  clear typing_narrowing.
  intros Q E F X P R e T PsubQ Typ.
  remember (F ++ X ~ bind_sub Q ++ E) as E'.
  generalize dependent F.
  induction Typ; intros F EQ; subst...
  Case "typing_var".
    analyze_binds H1...
  Case "typing_abs".
    pick fresh y and apply typing_abs; 
      try solve [eauto using wf_env_narrowing, wf_typ_narrowing, sub_narrowing, wf_sig_narrowing].
    rewrite <- app_assoc.
    apply H1...
  Case "typing_tabs".
    pick fresh Y and apply typing_tabs;
      try solve [eauto using wf_env_narrowing, wf_typ_narrowing, sub_narrowing, wf_sig_narrowing].
    rewrite <- app_assoc.
    apply H1...
  Case "typing_let".
    pick fresh y and apply typing_let...
    rewrite <- app_assoc.
    apply H1...
------
  clear typing_record_narrowing.
  intros Q E F X P R r T PsubQ Typ.
  remember (F ++ X ~ bind_sub Q ++ E) as E'.
  generalize dependent F.
  induction Typ; intros F EQ; subst...
Qed.


(************************************************************************ *)
(** ** Substitution preserves typing (8) *)

Lemma typing_through_subst_ee : forall U E F x R T e u,
  typing (F ++ x ~ bind_typ U ++ E) R e T ->
  typing E R u U ->
  typing (F ++ E) R (subst_ee x u e) T
with typing_record_through_subst_ee : forall U E F x R T r u,
  typing_record_comp (F ++ x ~ bind_typ U ++ E) R r T ->
  typing E R u U ->
  typing_record_comp (F ++ E) R (subst_ee_record x u r) T.

(* begin show *)

(** We provide detailed comments for the following proof, mainly to
    point out several useful tactics and proof techniques.

    Starting a proof with "Proof with <some tactic>" allows us to
    specify a default tactic that should be used to solve goals.  To
    invoke this default tactic at the end of a proof step, we signal
    the end of the step with three periods instead of a single one,
    e.g., "apply typing_weakening...". *)

Proof with simpl_env;
           eauto 5 using wf_typ_strengthening,
                         wf_env_strengthening,
                         wf_sig_strengthening,
                         sub_strengthening.
------
  clear typing_through_subst_ee.
  (** The proof proceeds by induction on the given typing derivation
      for e.  We use the [remember] tactic, along with [generalize
      dependent], to ensure that the goal is properly strengthened
      before we use induction. *)

  intros U E F x R T e u TypT TypU.
  remember (F ++ x ~ bind_typ U ++ E) as E'.
  generalize dependent F.
  induction TypT; intros F EQ; subst; simpl subst_ee...

  (** The [typing_var] case involves a case analysis on whether the
      variable is the same as the one being substituted for. *)

  Case "typing_var".
    destruct (x0 == x); try subst x0.

    (** In the case where [x0=x], we first observe that hypothesis
        [H0] implies that [T=U], since [x] can only be bound once in
        the environment.  The conclusion then follows from hypothesis
        [TypU] and weakening.  We can use the [analyze_binds_uniq]
        tactic, described in the MetatheoryEnv library, with [H0] to
        obtain the fact that [T=U]. *)

    SCase "x0 = x".
      analyze_binds_uniq H1.
        injection BindsTacVal; intros; subst.

        (** In order to apply [typing_weakening], we need to rewrite
            the environment so that it has the right shape.  (We could
            also prove a corollary of typing_weakening.)  The
            [rewrite_env] tactic, described in the Environment
            library, is one way to perform this rewriting. *)

        rewrite_env (empty ++ F ++ E).
        apply typing_weakening...

    (** In the case where [x0<>x], the result follows by an exhaustive
        case analysis on exactly where [x0] is bound in the
        environment.  We perform this case analysis by using the
        [analyze_binds] tactic, described in the MetatheoryEnv
        library. *)

    SCase "x0 <> x".
      analyze_binds H1.
        eauto using wf_env_strengthening, wf_sig_strengthening.
        eauto using wf_env_strengthening, wf_sig_strengthening.

  (** Informally, the [typing_abs] case is a straightforward
      application of the induction hypothesis, which is called [H0]
      here. *)

  Case "typing_abs".

    (** We use the "pick fresh and apply" tactic to apply the rule
        [typing_abs] without having to calculate the appropriate
        finite set of atoms. *)

    pick fresh y and apply typing_abs; try solve [eauto using wf_sig_strengthening].

    (** We cannot apply [H0] directly here.  The first problem is that
        the induction hypothesis has [(subst_ee open_ee)], whereas in
        the goal we have [(open_ee subst_ee)].  The lemma
        [subst_ee_open_ee_var] lets us swap the order of these two
        operations. *)

    rewrite subst_ee_open_ee_var...

    (** The second problem is how the concatenations are associated in
        the environments.  In the goal, we currently have

<<       (y ~ bind_typ V ++ F ++ E),
>>
        where concatenation associates to the right.  In order to
        apply the induction hypothesis, we need

<<        ((y ~ bind_typ V ++ F) ++ E).
>>
        We can use the [rewrite_env] tactic to perform this rewriting,
        or we can rewrite directly with an appropriate lemma from the
        MetatheoryEnv library. *)

    rewrite <- app_assoc.

    (** Now we can apply the induction hypothesis. *)

    apply H1...

  (** The remaining cases in this proof are straightforward, given
      everything that we have pointed out above. *)

  Case "typing_tabs".
    pick fresh Y and apply typing_tabs; try solve [eauto using wf_sig_strengthening].
    rewrite subst_ee_open_te_var...
    rewrite <- app_assoc.
    apply H1...
  Case "typing_let".
    pick fresh y and apply typing_let...
    rewrite subst_ee_open_ee_var...
    rewrite <- app_assoc.
    apply H1...
------
  clear typing_record_through_subst_ee.
  intros U E F x R T r u TypT TypU.
  remember (F ++ x ~ bind_typ U ++ E) as E'.
  generalize dependent F.
  induction TypT; intros F EQ; subst; simpl subst_ee_record...
Qed.
(* end show *)


(************************************************************************ *)
(** ** Type substitution preserves typing (11) *)

Lemma typing_through_subst_te : forall Q E F R Z e T P,
  wf_sig E R ->
  typing (F ++ Z ~ bind_sub Q ++ E) R e T ->
  sub E P Q ->
  typing (map (subst_tb Z P) F ++ E) R (subst_te Z P e) (subst_tt Z P T)
with typing_record_through_subst_te : forall Q E F R Z r T P,
  wf_sig E R ->
  typing_record_comp (F ++ Z ~ bind_sub Q ++ E) R r T ->
  sub E P Q ->
  typing_record_comp (map (subst_tb Z P) F ++ E) R (subst_te_record Z P r) (subst_tt Z P T).
Proof with simpl_env;
           eauto 6 using wf_env_subst_tb,
                         wf_typ_subst_tb,
                         sub_through_subst_tt,
                         wf_sig_weaken_head_map.
------
  clear typing_through_subst_te.
  intros Q E F R Z e T P WfSig Typ PsubQ.
  remember (F ++ Z ~ bind_sub Q ++ E) as G.
  generalize dependent F.
  induction Typ; intros F EQ; subst;
    simpl subst_te in *; simpl subst_tt in *...
  Case "typing_var".
    apply typing_var...
      rewrite (map_subst_tb_id E Z P);
        [ | auto | eapply fresh_mid_tail; eauto ].
      analyze_binds H1...
  Case "typing_abs".
    pick fresh y and apply typing_abs...
    rewrite subst_te_open_ee_var...
    rewrite_env (map (subst_tb Z P) (y ~ bind_typ V ++ F) ++ E).
    apply H1...
  Case "typing_tabs".
    pick fresh Y and apply typing_tabs...
    rewrite subst_te_open_te_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env (map (subst_tb Z P) (Y ~ bind_sub V ++ F) ++ E).
    apply H1...
  Case "typing_tapp".
    rewrite subst_tt_open_tt...
  Case "typing_let".
    pick fresh y and apply typing_let...
    rewrite subst_te_open_ee_var...
    rewrite_env (map (subst_tb Z P) (y ~ bind_typ T1 ++ F) ++ E).
    apply H1...
  Case "typing_ref".
    apply typing_ref...
    unshelve epose proof (wf_typ_from_binds_sig l T E R _ _)...
    rewrite <- subst_tt_fresh...
    apply notin_fv_wf with (E := E)...
    eapply fresh_mid_tail with (F := F) (a := bind_sub Q)...
------
  clear typing_record_through_subst_te.
  intros Q E F R Z e T P WfSig Typ PsubQ.
  remember (F ++ Z ~ bind_sub Q ++ E) as G.
  generalize dependent F.
  induction Typ; intros F EQ; subst;
    simpl subst_te in *; simpl subst_te_record in *; simpl subst_tt in *...
  
  Case "typing_record_ref".
    apply typing_record_ref...
    unshelve epose proof (wf_typ_from_binds_sig l T E R _ _)...
    rewrite <- subst_tt_fresh...
    apply notin_fv_wf with (E := E)...
    eapply fresh_mid_tail with (F := F) (a := bind_sub Q)...
Qed.


(* ********************************************************************** *)
(** * #<a name="preservation"></a># Preservation *)


(* ********************************************************************** *)
(** ** Inversion of typing and subtyping (13) *)

Lemma sub_inv_var : forall E S T (X : atom),
  in_intersection X (normal_form_typing T) ->
  sub E S T ->
  exists (S' : atom), in_intersection (typ_fvar S') (normal_form_typing S).
Proof with simpl in *; autorewrite with core in *; eauto;
  try repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub; revert X Int.
  dependent induction Sub; intros;
    try solve [simpl in *; inversion Int; eauto; discriminate]...

  - exfalso. eapply atom_in_intersection_merge_inversion with 
      (T := (normal_form_typing T2))...
  - exfalso. eapply atom_in_intersection_merge_inversion with 
      (T := (normal_form_typing T2))...
  - destruct (IHSub2 ltac:(eauto)) as [X' EQT2]; subst...
Qed.


Lemma sub_inv_readonly_var : forall E S T (X : atom),
  in_intersection (typ_mut mut_readonly X) (normal_form_typing T) ->
  sub E S T ->
  exists (S' : atom),
    in_intersection (typ_fvar S') (normal_form_typing S) \/
    in_intersection (typ_mut mut_readonly (typ_fvar S')) (normal_form_typing S).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub.
  generalize dependent X.
  dependent induction Sub; 
    intros; try discriminate;
    try solve
      [ inversion Int; eauto; try discriminate ];
    try solve 
      [ dependent induction Int; dependent induction eq; eauto; try discriminate ]; 
    subst...
  - unshelve epose proof
      (readonly_atom_in_normal_readonly_to_normal _ _  Int _) as [IntL | IntR]...
    + destruct (IHSub X) as [X' IntLI]...
      destruct IntLI as [IntLIL | IntLIR]...
    + unshelve epose proof (sub_inv_var E T1 X _) as [X' X'inT1]...      
  - unshelve epose proof
      (readonly_atom_in_normal_readonly_to_normal _ _ Int _) as [IntL | IntR]...
    + unshelve epose proof (sub_inv_var E T1 X _) as [X' X'inT1]...
  - destruct (IHSub2 X) as [X' [IntX' | IntMX']]...
    unshelve epose proof (sub_inv_var E T1 X' _) as [X'' X''inT1]...
Qed.

Lemma sub_inv_arrow : forall E S T1 T2 T,
  (in_intersection (typ_arrow T1 T2) (normal_form_typing T)) ->
  sub E S T ->
  (exists (S' : atom), in_intersection S' (normal_form_typing S))
    \/ 
  (exists (S' : atom), in_intersection (typ_mut mut_readonly S') (normal_form_typing S))
    \/
  (exists S1 S2,
    in_normal_form S1 /\
    in_normal_form S2 /\
    in_intersection (typ_arrow S1 S2) (normal_form_typing S) /\ sub E T1 S1 /\ sub E S2 T2).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub.
  generalize dependent T1.
  generalize dependent T2.
  dependent induction Sub; intros * Int; simpl in *;
    try solve [inversion Int; eauto; try discriminate]...
  - inversion Int; inversion H; subst... right. right.
    exists (normal_form_typing S1)...
    exists (normal_form_typing S2)...
    repeat ( split; eauto )...
  - destruct (IHSub T0 T3) as [[S' IntS'] | [[S' InS'RO] | SCase3]]...
    * unshelve epose proof (atom_in_intersection_readonly_normal _ _ IntS') as AuxS';
      simpl in *...
      destruct AuxS' as [InS'T1 | InRS'RT1]...
    * unshelve epose proof (readonly_atom_in_normal_to_normal _ _ InS'RO _)...
    * destruct SCase3 as [S1 [S2 [NormS1 [NormS2 [IntS1S2 [SubS1 SubS2]]]]]]...
      unshelve epose proof (in_intersection_arrow_normal_in_merge _ _ _ IntS1S2 _) as Aux...
      right; right; exists S1; exists S2...
  - (** transitivity *)
    destruct (IHSub2 T0 T4 Int) as [Case1 | [Case2 | Case3]]...
    * destruct Case1 as [S' InS'T2]...
    * destruct Case2 as [S' InMS'T2]...
      unshelve
        epose proof (sub_inv_readonly_var E T1 (normal_form_typing T2) S' _ _) as [S'' [InS''T1 | InRS''T1]]... 
    * destruct Case3 as [S1 [S2 [NormS1 [NormS2 [IntS2 [SubS1 SubS2]]]]]]...
      destruct (IHSub1 S2 S1) as [SCase1 | [SCase2 | SCase3]]...
      + right... right...
        destruct SCase3 as [S3 [S4 [NormS3 [NormS4 [IntS3S4 [SubS3 SubS4]]]]]]...
        exists S3; exists S4; repeat (split; eauto)...
  - right; right.
    exists T3; exists T0; repeat (split; eauto 4);
    try solve [apply intersection_of_normal_is_normal in Int; inversion Int; eauto];
    try solve [apply sub_reflexivity; eauto 4].
  - right; right.
    exists T3; exists T0; repeat (split; eauto 4);
    try solve [apply intersection_of_normal_is_normal in Int; inversion Int; eauto];
    try solve [apply sub_reflexivity; eauto 4].
Qed.


Lemma sub_inv_all : forall E S T1 T2 T,
  (in_intersection (typ_all T1 T2) (normal_form_typing T)) ->
  sub E S T ->
  (exists (S' : atom), in_intersection S' (normal_form_typing S))
    \/ 
  (exists (S' : atom), in_intersection (typ_mut mut_readonly S') (normal_form_typing S))
    \/
  (exists L S1 S2,
    in_normal_form S1 /\
    in_intersection (typ_all S1 S2) (normal_form_typing S) /\
    sub E T1 S1  /\
    (forall X, X `notin` L -> in_normal_form (open_tt S2 X) /\
      sub (X ~ bind_sub T1 ++ E) (open_tt S2 X) (open_tt T2 X))).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub.
  generalize dependent T1.
  generalize dependent T2.
  dependent induction Sub; intros * Int; simpl in *;
    try solve [inversion Int; eauto; try discriminate]...
  - inversion Int; subst; inversion H1; subst; right; right...
    exists L.
    exists (normal_form_typing S1)...
    exists (normal_form_typing S2)...
    repeat ( split; eauto 4 ).
    * unshelve epose proof (H X _); eauto 4. rewrite <- normal_form_open_tt...
    * unshelve epose proof (H X _); eauto 4.
      simpl_env in *.
      rewrite_env ( empty ++ [(X, bind_sub (normal_form_typing T1))] ++ E ).
      eapply sub_narrowing with (Q := T1)...
      repeat rewrite <- normal_form_open_tt...
  - destruct (IHSub T0 T3) as [[S' IntS'] | [[S' InS'RO] | SCase3]]...
    * unshelve epose proof (atom_in_intersection_readonly_normal _ _ IntS') as AuxS';
      simpl in *...
      destruct AuxS' as [InS'T1 | InRS'RT1]...
    * unshelve epose proof (readonly_atom_in_normal_to_normal _ _ InS'RO)...
    * destruct SCase3 as [L [S1 [S2 [NormS1 [IntS1S2 [SubS1 SubS2]]]]]]...
      unshelve epose proof (in_intersection_all_normal_in_merge _ _ _ IntS1S2 _) as Aux...
      right; right.
        exists L; exists S1; exists S2...
  - (** transitivity *)
    destruct (IHSub2 T0 T4 Int) as [Case1 | [Case2 | Case3]]...
    * destruct Case1 as [S' InS'T2]...
    * destruct Case2 as [S' InMS'T2]...
      unshelve
        epose proof (sub_inv_readonly_var E T1 (normal_form_typing T2) S' _ _) as [S'' [InS''T1 | InRS''T1]]... 
    * destruct Case3 as [L [S1 [S2 [NormS1 [IntS1S2 [SubS1 SubS2]]]]]]...
      destruct (IHSub1 S2 S1) as [SCase1 | [SCase2 | SCase3]]...
      + right... right...
        destruct SCase3 as [L' [S3 [S4 [NormS3 [IntS3S4 [SubS3 SubS4]]]]]]...
        eapply intersection_of_normal_is_normal in IntS3S4 as S3Normal...
        inversion S3Normal; subst...
        exists (L `union` L' `union` L0); exists S3; exists S4... 
        repeat (split; eauto 4)...
        destruct (SubS2 X) as [NormS2 SubS2X]; eauto 4.
        destruct (SubS4 X) as [NormS4 SubS4X]; eauto 4.
        simpl_env in *.
        rewrite_env (empty ++ X ~ bind_sub T4 ++ E) in SubS2X.
        rewrite_env (empty ++ X ~ bind_sub S1 ++ E) in SubS4X.
        rewrite_env (empty ++ X ~ bind_sub T4 ++ E).
        eapply sub_transitivity with (Q := open_tt S2 X); try assumption.
        eapply sub_narrowing with (Q := S1)...
  - right. right.
    apply intersection_of_normal_is_normal in Int as NormComp; try inversion NormComp; subst...
    exists (L `union` dom E); exists T3; exists T0; repeat split...
    * apply sub_reflexivity; simpl_env; eauto 4.
      econstructor; eauto 4.
      eapply wf_typ_open with (T1 := T3); eauto 4.
      eapply wf_typ_from_in_intersection; eauto 4.
      eapply wf_typ_weaken_head; eauto 4.
  - right; right.
    apply intersection_of_normal_is_normal in Int as NormComp; try inversion NormComp; subst...
    exists (L `union` dom E); exists T3; exists T0; repeat split...
    * apply sub_reflexivity; simpl_env; eauto 4.
      econstructor; eauto 4.
      eapply wf_typ_open with (T1 := T3); eauto 4.
      eapply wf_typ_from_in_intersection; eauto 4.
      eapply wf_typ_weaken_head...
Qed.

Lemma sub_inv_ref : forall E S T1 T,
  in_intersection (typ_box T1) (normal_form_typing T) ->
  sub E S T ->
  (exists S' : atom, in_intersection S' (normal_form_typing S))
    \/
  (exists S1, in_intersection (typ_box S1) (normal_form_typing S) /\ sub E T1 S1 /\ sub E S1 T1).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub. generalize dependent T1. 
  dependent induction Sub; intros; try solve [try simpl in *; inversion Int; subst; eauto; try discriminate];
    simpl in *...
  - inversion Int; inversion H; subst...
    right... exists (normal_form_typing T1)...
    repeat (split; eauto)...
  - exfalso... eapply box_in_intersection_merge_inversion...
  - destruct (IHSub2 T0) as [[S1 EqS] | [S1 [Eq [Sub3 Sub4]]]]; subst...
    destruct (IHSub1 S1) as [[S2 EqS2] | [S2 [Eq2 [Sub5 Sub6]]]]; subst...
    right... exists S2...
  - right... exists T0...
    assert (wf_typ E (normal_form_typing T1))...
    assert (wf_typ E (typ_box T0))...
    assert (wf_typ E T0)...
    repeat (split; eauto 4)...
  - right... exists T0...
    repeat (split; eauto 4)...
Qed.

Lemma sub_inv_readonly_ref : forall E S T1 T,
  in_intersection (typ_box T1) (normal_form_typing T) \/
  in_intersection (typ_mut mut_readonly (typ_box T1)) (normal_form_typing T) ->
  sub E S T ->
  (exists S' : atom, in_intersection S' (normal_form_typing S))
    \/
  (exists (S' : atom), in_intersection (typ_mut mut_readonly S') (normal_form_typing S))
    \/
  (exists S1, in_intersection (typ_box S1) (normal_form_typing S) /\ sub E T1 S1 /\ sub E S1 T1)
    \/
  (exists S1, in_intersection (typ_mut mut_readonly (typ_box S1)) (normal_form_typing S) /\ sub E T1 S1 /\ sub E S1 T1).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub. generalize dependent T1. 
  dependent induction Sub; intros; 
    try solve [simpl in *; destruct Int as [Int|Int]; inversion Int; subst; eauto; try discriminate];
    simpl in *...
  - destruct Int as [Int|Int]; inversion Int; inversion H; subst...
    right... right... left...  exists (normal_form_typing T1)...
    repeat split...
  - destruct Int as [Int|Int];
      try solve [exfalso; eapply box_in_intersection_merge_inversion; eauto].
    unshelve epose proof
      (in_intersection_readonly_box_merge_in_normal _ _ Int _) as [IntT0 | IntT0Mut]...
    * destruct (sub_inv_ref _ _ _ _ IntT0 Sub) as [[S' IntS'] | [S1 [IntS1 [SubL SubR]]]]...
      + right...
      + right... right... right... exists S1...
    * destruct (IHSub T0) as 
        [[S' IntS] | [[S' IntS'] | [[S1 [IntS1 [SubL SubR]]] | [S1 [IntS1 [SubL SubR]]]]]]...
      + right...
      + right...
      + right... right... right... exists S1...
      + right... right... right... exists S1...
  - destruct (IHSub2 T0) as
      [[S' IntS'] | [[S' IntS'] | [[S1 [IntS1 [SubL SubR]]] | [S1 [IntS1 [SubL SubR]]]]]]...
    + unshelve epose proof (sub_inv_readonly_var _ _ _ _ IntS' Sub1) as
      [S'' [IntS'' | IntS''RO]]...
    + destruct (sub_inv_ref _ _ _ _ IntS1 Sub1) as [[S'' IntS''] | [S2 [IntS2 [SubL2 SubR2]]]]...
      right... right... left... exists S2...
    + destruct (IHSub1 S1) as
      [[S'' IntS'] | [[S'' IntS''] | [[S2 [IntS2 [SubL2 SubR2]]] | [S2 [IntS2 [SubL2 SubR2]]]]]]...
      * right... right... left... exists S2...
      * right... right... right... exists S2...
  - destruct Int as [Int|Int];
      right; right...
    + left; exists T0... repeat split...
    + right; exists T0... repeat split...
  - destruct Int as [Int|Int];
      right; right...
    + left; exists T0... repeat split...
    + right; exists T0... repeat split...
Qed.

(** #<a name="lemma_4.4"></a># Lemma 4.4: Record Subtyping Inversion *)
Lemma sub_inv_record : forall E S a T1 T,
  in_intersection (typ_record a T1) (normal_form_typing T) ->
  sub E S T ->
  (exists S' : atom, in_intersection S' (normal_form_typing S))
    \/
  (exists S1, in_intersection (typ_record a S1) (normal_form_typing S) /\ sub E T1 S1 /\ sub E S1 T1).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub. generalize dependent T1. generalize dependent a.
  dependent induction Sub; intros; try solve [try simpl in *; inversion Int; subst; eauto; try discriminate];
    simpl in *...
  - exfalso... eapply record_in_intersection_merge_inversion...
  - destruct (IHSub2 a T0) as [[S1 EqS] | [S1 [Eq [Sub3 Sub4]]]]; subst...
    destruct (IHSub1 a S1) as [[S2 EqS2] | [S2 [Eq2 [Sub5 Sub6]]]]; subst...
    right... exists S2...
  - right... exists T0...
    assert (wf_typ E (normal_form_typing T1)); eauto 4.
    assert (wf_typ E (typ_record a T0)); eauto 4.
    assert (wf_typ E T0); eauto 4.
    repeat (split; eauto 4)...
  - right... exists T0...
    repeat (split; eauto 4)...
  - inversion Int; subst; try discriminate...
    inversion H; subst...
    right... exists (normal_form_typing T1)...
    repeat (split; eauto 4)...
Qed.

(** #<a name="lemma_4.6"></a># Lemma 4.6: Read-Only Record Subtyping Inversion *)
Lemma sub_inv_readonly_record : forall E S a T1 T,
  in_intersection (typ_record a T1) (normal_form_typing T) \/
  in_intersection (typ_mut mut_readonly (typ_record a T1)) (normal_form_typing T) ->
  sub E S T ->
  (exists S' : atom, in_intersection S' (normal_form_typing S))
    \/
  (exists (S' : atom), in_intersection (typ_mut mut_readonly S') (normal_form_typing S))
    \/
  (exists S1, in_intersection (typ_record a S1) (normal_form_typing S) /\ sub E S1 T1)
    \/
  (exists S1, in_intersection (typ_mut mut_readonly (typ_record a S1)) (normal_form_typing S) /\ sub E S1 T1).
Proof with simpl in *; autorewrite with core in *;
  (eauto using sub_inv_var, sub_reflexivity);
  repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Int Sub. generalize dependent a. generalize dependent T1. 
  dependent induction Sub; intros; 
    try solve [simpl in *; destruct Int as [Int|Int]; inversion Int; subst; eauto; try discriminate];
    simpl in *...
  - destruct Int as [Int|Int];
      try solve [exfalso; eapply record_in_intersection_merge_inversion; eauto].
    unshelve epose proof
      (in_intersection_readonly_record_merge_in_normal _ _ _ Int _) as [IntT0 | IntT0Mut]...
    * destruct (sub_inv_record _ _ _ _ _ IntT0 Sub) as [[S' IntS'] | [S1 [IntS1 [SubL SubR]]]]...
      + right...
      + right... right... right...
    * destruct (IHSub T0 a) as 
        [[S' IntS] | [[S' IntS'] | [[S1 [IntS1 SubL]] | [S1 [IntS1 SubL]]]]]...
      + right...
      + right...
      + right... right... right...
      + right... right... right...
  - destruct (IHSub2 T0 a) as
      [[S' IntS'] | [[S' IntS'] | [[S1 [IntS1 SubL]] | [S1 [IntS1 SubL]]]]]...
    + unshelve epose proof (sub_inv_readonly_var _ _ _ _ IntS' Sub1) as
      [S'' [IntS'' | IntS''RO]]...
    + destruct (sub_inv_record _ _ _ _ _ IntS1 Sub1) as [[S'' IntS''] | [S2 [IntS2 [SubL2 SubR2]]]]...
      right... right...
    + destruct (IHSub1 S1 a) as
      [[S'' IntS'] | [[S'' IntS''] | [[S2 [IntS2 SubL2]] | [S2 [IntS2 SubL2]]]]]...
      * right... right...
      * right... right...
  - destruct Int as [Int|Int];
      right; right...
    + left; exists T0... repeat split...
    + right; exists T0... repeat split...
  - destruct Int as [Int|Int];
      right; right...
    + left; exists T0... repeat split...
    + right; exists T0... repeat split...
  - destruct Int as [Int|Int];
      right; right...
    + inversion Int; subst.
      inversion select (typ_record _ _ = typ_record _ _); subst... 
      left; eexists; subst...
    + inversion Int; subst...
  - destruct Int as [Int|Int]; inversion Int; inversion H; subst...
    right... right... right...  exists (normal_form_typing T1); split...
Qed.

(* ********************************************************************** *)
(** ** Sub and Typing canonical forms (13 1/2)                            *)

Lemma sub_canonical_top : forall E S T,
  (forall S', in_intersection_component S' (normal_form_typing S) -> S' = typ_top) ->
  sub E S T ->
  (forall T', in_intersection_component T' (normal_form_typing T) -> T' = typ_top).
Proof with simpl in *; autorewrite with core in *; 
  eauto using sub_inv_var; 
  repeat (fold merge_mutability in *; repeat fold normal_form_typing in *);
  try discriminate.
  intros * CompS Sub.
  dependent induction Sub; intros T' IntComp; destruct IntComp as [Primitive IntT];
    simpl in *; try solve [inversion IntT; eauto]; try solve [apply CompS; split; eauto]...
  - exfalso...
  - exfalso...
  - exfalso...
  - exfalso...
  - unshelve epose proof (in_intersection_merge _ _ _ _ IntT) as [InT' | [T1' [EqT1' IntT1']]]...
    + apply IHSub...
      intros S' IntS'...
      apply in_intersection_component_to_merge in IntS'...
      destruct IntS' as [IntS' | IntS'R]...
    + unshelve epose proof (in_intersection_component_top_merged _ _ CompS) as CompS'...
      unshelve epose proof (IHSub CompS') as IntCompT2. subst...
      eapply mut_in_intersection_is_component in IntT...
      eapply in_intersection_component_merged_top in IntCompT2...
  - eapply in_intersection_component_merged_top in IHSub...
  - inversion IntT; subst... 
    exfalso...
  - inversion IntT; subst...
    exfalso...
  - exfalso...
Qed.

#[export] Hint Extern 6 False => let Bad := fresh "Bad" in 
  match goal with
  | H : forall S', in_intersection_component S' ?T1 -> exists S1 S2, S' = typ_arrow S1 S2 |- _ =>
    eenough (exists S1 S2, T1 = typ_arrow S1 S2) as 
      Bad by (destruct Bad as [? [? ?]]; discriminate); apply H; split; eauto
  end : core.
 
Lemma sub_canonical_arrow : forall E S T,
  (forall S', in_intersection_component S' (normal_form_typing S) -> 
    S' = typ_top \/ exists S1 S2, S' = typ_arrow S1 S2) ->
  sub E S T ->
  (forall T', in_intersection_component T' (normal_form_typing T) -> 
    T' = typ_top \/ exists T1 T2, T' = typ_arrow T1 T2).
Proof with simpl in *; autorewrite with core in *; 
  eauto using sub_inv_var; 
  repeat (fold merge_mutability in *; repeat fold normal_form_typing in *);
  try discriminate.
  intros * CompS Sub.
  dependent induction Sub; intros T' IntComp; destruct IntComp as [Primitive IntT];
    simpl in *; try solve [inversion IntT; eauto]; try solve [apply CompS; split; eauto]...
  - exfalso...
  - exfalso...
  - exfalso...
  - unshelve epose proof (in_intersection_merge _ _ _ _ IntT) as [InT' | [T1' [EqT1' IntT1']]]...
    + apply IHSub...
      intros S' IntS'...
      apply in_intersection_component_to_merge in IntS'...
      destruct IntS' as [IntS' | IntS'R]...
      unshelve epose proof (CompS (merge_mutability S' mut_readonly) _) as [S'Top | S'Arrow]...
    + unshelve epose proof (in_intersection_component_top_or_arrow_merged _ _ CompS) as CompS'...
      unshelve epose proof (IHSub CompS') as IntCompT2. subst...
      eapply mut_in_intersection_is_component in IntT...
      eapply in_intersection_component_merged_top_or_arrow in IntCompT2...
  - eapply in_intersection_component_merged_top_or_arrow in IHSub...
  - inversion IntT; subst...
    exfalso...
  - inversion IntT; subst...
    exfalso...
  - exfalso...
Qed.

Lemma sub_canonical_box : forall E S T,
  (forall S', in_intersection_component S' (normal_form_typing S) -> 
    S' = typ_top \/ (exists S1, S' = typ_box S1) \/ (exists S1, S' = typ_mut mut_readonly (typ_box S1))) ->
  sub E S T ->
  (forall T', in_intersection_component T' (normal_form_typing T) -> 
    T' = typ_top \/ (exists T1, T' = typ_box T1) \/ (exists T1, T' = typ_mut mut_readonly (typ_box T1))).
Proof with simpl in *; autorewrite with core in *; 
  eauto using sub_inv_var; 
  repeat (fold merge_mutability in *; repeat fold normal_form_typing in *);
  try discriminate.
  intros * CompS Sub.
  dependent induction Sub; intros T' IntComp; destruct IntComp as [Primitive IntT];
    simpl in *; try solve [inversion IntT; eauto]; try solve [apply CompS; split; eauto]...
  - exfalso...
  - exfalso...
  - exfalso...
  - unshelve epose proof (in_intersection_merge _ _ _ _ IntT) as [InT' | [T1' [EqT1' IntT1']]]...
    + apply IHSub...
      intros S' IntS'...
      apply in_intersection_component_to_merge in IntS'...
      destruct IntS' as [IntS' | IntS'R]...
      unshelve epose proof (CompS (merge_mutability S' mut_readonly) _) as [S'Top | [[S1 EqBox1] | [S1 EqBox1RO]]]...
      exfalso... eapply merge_mutability_inversion_box...
    + unshelve epose proof (in_intersection_component_top_or_box_or_readonly_box_merged _ _ CompS) as CompS'...
      unshelve epose proof (IHSub CompS') as IntCompT2. subst...
      eapply mut_in_intersection_is_component in IntT...
      eapply in_intersection_component_merged_top_or_box_or_readonly_box in IntCompT2 as
        [Bad | [S1 Eq]]...
  - eapply in_intersection_component_merged_top_or_box_or_readonly_box with (S := T') in IHSub 
      as [Eq | [S1 Eq]]...
  - inversion IntT; subst...
    exfalso...
  - exfalso...
  - inversion IntT; subst...
    exfalso...
Qed.


Lemma sub_implies_sub_merge_mutability : forall E S T,
  sub E S T ->
  sub E (merge_mutability S mut_readonly) (merge_mutability T mut_readonly).
Proof with simpl in *; autorewrite with core in *;
  eauto 4 using sub_reflexivity; repeat fold merge_mutability in *;
  repeat fold normal_form_typing in *.
  intros * Sub.
  induction Sub...
  * eapply sub_transitivity with (Q := typ_mut mut_readonly U)...
    apply sub_readonly... eapply sub_trans_tvar...
    eapply sub_transitivity with (Q := merge_mutability U mut_readonly)...
    apply merge_mutability_sub...
  * apply sub_all with (L := L)...
  * apply sub_transitivity with (Q := typ_mut mut_readonly T1)...
    apply sub_merge_mutability...
  * eapply sub_denormalize...
    rewrite 2 normal_form_merge_mutability_exchange...
Qed.
  
#[export] Hint Resolve sub_implies_sub_merge_mutability : core.


Lemma sub_canonical_readonly_box : forall E S T,
  (forall S', in_intersection_component S' (normal_form_typing S) -> 
    S' = typ_top \/ (exists S1, S' = typ_mut mut_readonly (typ_box S1))) ->
  sub E S T ->
  (forall T', in_intersection_component T' (normal_form_typing T) -> 
    T' = typ_top \/ (exists T1, T' = typ_mut mut_readonly (typ_box T1))).
Proof with simpl in *; autorewrite with core in *; 
  eauto 4 using sub_inv_var, sub_reflexivity; 
  repeat (fold merge_mutability in *; repeat fold normal_form_typing in *);
  try discriminate.
  intros * CompS Sub.
  dependent induction Sub; intros T' IntComp; destruct IntComp as [Primitive IntT];
    simpl in *; try solve [inversion IntT; eauto]; try solve [apply CompS; split; eauto]...
  - exfalso...
  - exfalso...
  - exfalso...
  - exfalso...
  - unshelve epose proof (sub_canonical_box E (merge_mutability (normal_form_typing T1) mut_readonly)
                                              (merge_mutability (normal_form_typing T2) mut_readonly)
                                              _ _ _ _) as SubBox...
    + intros S' Int. autorewrite with core in *...
      rewrite normal_form_merge_mutability_exchange in *...
      destruct (CompS S')...
    + autorewrite with core in *...
      rewrite normal_form_merge_mutability_exchange in *...
    + destruct SubBox as [EqTop | [[S1 EqBox] | [S1 EqReadBox]]]; subst...
      exfalso...
      eapply merge_mutability_inversion_box_intersection...
  - unshelve epose proof (in_intersection_merge _ _ _ _ IntT) as [InT' | [T1' [EqT1' IntT1']]];
      subst...
    unshelve epose proof (sub_canonical_box E (normal_form_typing T1)
                                              (merge_mutability (normal_form_typing T2) mut_readonly)
                                              _ _ 
                                              (typ_mut mut_readonly T1')
                                              _) as SubBox...
    + intros S' Int. autorewrite with core in *...
      destruct (CompS S')...
    + apply sub_transitivity with (Q := T1)...
      apply sub_transitivity with (Q := T2)...
      apply sub_transitivity with (Q := normal_form_typing T2)...
      apply sub_transitivity with (Q := typ_mut mut_readonly (normal_form_typing T2))...
      apply merge_mutability_sub...
    + autorewrite with core in *...
      rewrite normal_form_merge_mutability_exchange in *...
    + destruct SubBox as [EqTop | [[S1 EqBox] | [S1 EqReadBox]]]; subst...
  - inversion IntT; subst... exfalso...
  - inversion IntT; subst... exfalso...
  - exfalso...
Qed.

Lemma sub_canonical_record : forall E S T,
  (forall S', in_intersection_component S' (normal_form_typing S) -> 
    S' = typ_top \/ (exists a S1, S' = typ_record a S1) \/ (exists a S1, S' = typ_mut mut_readonly (typ_record a S1))) ->
  sub E S T ->
  (forall T', in_intersection_component T' (normal_form_typing T) -> 
    T' = typ_top \/ (exists b T1, T' = typ_record b T1) \/ (exists b T1, T' = typ_mut mut_readonly (typ_record b T1))).
Proof with simpl in *; autorewrite with core in *; 
  eauto 4 using sub_inv_var, sub_reflexivity; 
  repeat (fold merge_mutability in *; repeat fold normal_form_typing in *);
  try discriminate.
  intros * CompS Sub.
  dependent induction Sub; intros T' IntComp; destruct IntComp as [Primitive IntT];
    simpl in *; try solve [inversion IntT; eauto]; try solve [apply CompS; split; eauto]...
  - exfalso...
  - exfalso...
  - exfalso...
  - exfalso...
  - unshelve epose proof (in_intersection_merge _ _ _ _ IntT) as [InT' | [T1' [EqT1' IntT1']]]...
    + apply IHSub...
      intros S' IntS'...
      apply in_intersection_component_to_merge in IntS'...
      destruct IntS' as [IntS' | IntS'R]...
      unshelve epose proof (CompS (merge_mutability S' mut_readonly) _) as [S'Top | [[S1 EqBox1] | [S1 EqBox1RO]]]...
      exfalso... eapply merge_mutability_inversion_record...
    + unshelve epose proof (in_intersection_component_top_or_record_or_readonly_record_merged _ _ CompS) as CompS'...
      unshelve epose proof (IHSub CompS') as IntCompT2. subst...
      eapply mut_in_intersection_is_component in IntT...
      eapply in_intersection_component_merged_top_or_record_or_readonly_record in IntCompT2 as
        [Bad | [S1 Eq]]...
  - eapply in_intersection_component_merged_top_or_record_or_readonly_record with (S := T') in IHSub 
      as [Eq | [S1 Eq]]...
  - inversion IntT; subst...
    exfalso...
Qed.

Lemma sub_canonical_readonly_record : forall E S T,
  (forall S', in_intersection_component S' (normal_form_typing S) -> 
    S' = typ_top \/ (exists a S1, S' = typ_mut mut_readonly (typ_record a S1))) ->
  sub E S T ->
  (forall T', in_intersection_component T' (normal_form_typing T) -> 
    T' = typ_top \/ (exists b T1, T' = typ_mut mut_readonly (typ_record b T1))).
Proof with simpl in *; autorewrite with core in *; 
  eauto 4 using sub_inv_var, sub_reflexivity; 
  repeat (fold merge_mutability in *; repeat fold normal_form_typing in *);
  try discriminate.
  intros * CompS Sub.
  dependent induction Sub; intros T' IntComp; destruct IntComp as [Primitive IntT];
    simpl in *; try solve [inversion IntT; eauto]; try solve [apply CompS; split; eauto]...
  - exfalso...
  - exfalso...
  - exfalso...
  - exfalso...
  - unshelve epose proof (sub_canonical_record E (merge_mutability (normal_form_typing T1) mut_readonly)
                                                 (merge_mutability (normal_form_typing T2) mut_readonly)
                                                 _ _ _ _) as SubBox...
    + intros S' Int. autorewrite with core in *...
      rewrite normal_form_merge_mutability_exchange in *...
      destruct (CompS S')...
    + autorewrite with core in *...
      rewrite normal_form_merge_mutability_exchange in *...
    + destruct SubBox as [EqTop | [[a [S1 EqBox]] | [a [S1 EqReadBox]]]]; subst...
      exfalso...
      eapply merge_mutability_inversion_record_intersection...
  - unshelve epose proof (in_intersection_merge _ _ _ _ IntT) as [InT' | [T1' [EqT1' IntT1']]];
      subst...
    unshelve epose proof (sub_canonical_record  E (normal_form_typing T1)
                                                (merge_mutability (normal_form_typing T2) mut_readonly)
                                                _ _ 
                                                (typ_mut mut_readonly T1')
                                                _) as SubBox...
    + intros S' Int. autorewrite with core in *...
      destruct (CompS S')...
    + apply sub_transitivity with (Q := T1)...
      apply sub_transitivity with (Q := T2)...
      apply sub_transitivity with (Q := normal_form_typing T2)...
      apply sub_transitivity with (Q := typ_mut mut_readonly (normal_form_typing T2))...
      apply merge_mutability_sub...
    + autorewrite with core in *...
      rewrite normal_form_merge_mutability_exchange in *...
    + destruct SubBox as [EqTop | [[a [S1 EqBox]] | [a [S1 EqReadBox]]]]; subst...
  - inversion IntT; subst... exfalso...
  - exfalso...
Qed.

(** Canonical typing forms. *)

Lemma typing_canonical_ref : forall E R l T,
  typing E R (exp_ref l) T ->
  (forall T', in_intersection_component T' (normal_form_typing T) 
  -> T' = typ_top \/ (exists U1, T' = typ_box U1) \/ (exists U1, T' = typ_mut mut_readonly (typ_box U1))).
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros * Typ.
  dependent induction Typ; subst; intros T' IntCompT'...
  - unshelve epose proof (sub_canonical_box _ _ _ _ H0)...
  - inversion IntCompT' as [Prim Int]...
    inversion Int; subst...
Qed.

Lemma typing_canonical_sealed_ref : forall E R l T,
  typing E R (exp_seal (exp_ref l)) T ->
  (forall T', in_intersection_component T' (normal_form_typing T) 
    -> T' = typ_top \/ exists U1, T' = typ_mut mut_readonly (typ_box U1)).
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros * Typ.
  dependent induction Typ; subst; intros T' IntCompT'...
  - unshelve epose proof (sub_canonical_readonly_box _ _ _ _ H0)...
  - unshelve epose proof (typing_canonical_ref _ _ _ _ Typ) as CanForm...
    unshelve epose proof (in_intersection_component_inversion_merge _ _ IntCompT')
      as [M [IntCompM Eq]]; subst...
    destruct (CanForm M IntCompM) as [EqTop | [[U EqBox] | [U EqReadBox]]]; subst...
Qed.

Lemma typing_canonical_record_rec : forall E R r T,
  typing_record_comp E R r T ->
  (forall T', in_intersection_component T' (normal_form_typing T)
    -> T' = typ_top \/ (exists a U1, T' = typ_record a U1)).
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros * Typ.
  dependent induction Typ; subst; intros T' IntCompT'...
  - destruct IntCompT' as [Prim Int]...
    inversion Int as [?|? ? ? IntX|?]; subst...
    + exfalso...
    + inversion IntX...
  - destruct IntCompT' as [Prim Int]...
    inversion Int as [?|? ? ? IntX|?]; subst...
    + exfalso...
    + inversion IntX...
Qed.

Lemma typing_canonical_record : forall E R r T,
  typing E R (exp_record r) T ->
  (forall T', in_intersection_component T' (normal_form_typing T)
    -> T' = typ_top \/ (exists a U1, T' = typ_record a U1) \/ (exists a U1, T' = typ_mut mut_readonly (typ_record a U1))).
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros * Typ.
  dependent induction Typ; subst; intros T' IntCompT'...
  - unshelve epose proof (sub_canonical_record _ _ _ _ H0)...
  - destruct (typing_canonical_record_rec _ _ _ _ H T')...
Qed.

(** #<a name="lemma_4.8"></a># Lemma 4.8 -- Sealed records are given a readonly type. *)
Lemma typing_canonical_sealed_record : forall E R r T,
  typing E R (exp_seal (exp_record r)) T ->
  (forall T', in_intersection_component T' (normal_form_typing T)
    -> T' = typ_top \/ (exists a U1, T' = typ_mut mut_readonly (typ_record a U1))).
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros * Typ.
  dependent induction Typ; subst; intros T' IntCompT'...
  - unshelve epose proof (sub_canonical_readonly_record _ _ _ _ H0)...
  - apply in_intersection_component_inversion_merge in IntCompT' as
      [M [IntM Eq]]; subst...
    destruct (typing_canonical_record E R r T Typ M) as [EqTop | [[a [U1 EqM]]| [a [U1 EqM]]]]; subst...
Qed.


(* ********************************************************************** *)
(** ** Store typing (14) *)

Lemma typing_store_free_store : forall E R s l,
  typing_store E R s ->
  ~ LabelMapImpl.In l s ->
  LabelSetImpl.notin l (Signatures.dom R).
Proof with eauto.
  intros E R s l TypS Fr.
  specialize (TypS l) as [Fwd _].
  intro Binds.
  apply Signatures.binds_In_inv in Binds.
  destruct Binds as [Sig Binds].
  destruct Sig as [T]...
  destruct (Fwd T) as [v [MapsTo _]]...
  enough (LabelMapImpl.In l s)...
  exists v...
Qed.

Lemma typing_store_free_sig : forall E R s l,
  typing_store E R s ->
  LabelSetImpl.notin l (Signatures.dom R) ->
  ~ LabelMapImpl.In l s.
Proof with eauto.
  intros E R s l TypS Fr.
  specialize (TypS l) as [_ Back].
  intro Binds.
  destruct Binds as [v Binds]...
  destruct (Back v) as [T [_ [_ BindsDom]]]...
Qed.

Lemma typing_store_add : forall E R s l e T,
  typing_store E R s ->
  ~ LabelMapImpl.In l s ->
  typing E R e T ->
  value e ->
  typing_store E (l ~ bind_sig T ++ R) (LabelMapImpl.add l e s).
Proof with eauto using typing_weakening_sig_head, typing_store_free_store.
  intros E R s l e T WfTypS Fr Typ Val.
  intros l'.
  split; destruct (l' == l); subst...
  - intros T' Hyp; exists e; repeat split...
    LabelMapFacts.map_iff...
    Signatures.analyze_binds Hyp...
    inversion BindsTac; inversion H; subst...
    apply Signatures.binds_In in BindsTac...
    eapply typing_store_free_store in Fr...
    exfalso...
  - intros T' Hyp; pose proof (WfTypS l') as [Fwd Back]...
    Signatures.analyze_binds Hyp...
    + inversion BindsTac; inversion H; subst. exfalso...
    + eapply Fwd in BindsTac as [v [MapsTo [TypingV ValueV]]]...
      exists v; repeat split...
      LabelMapFacts.map_iff...
  - intros v.  LabelMapFacts.map_iff.
    intros Hyp. destruct Hyp as [Hyp | Hyp]...
    + destruct Hyp; subst...
      exists T; repeat split...
    + destruct Hyp; exfalso...
  - intros v.  LabelMapFacts.map_iff.
    intros Hyp. destruct Hyp as [Hyp | Hyp]...
    + destruct Hyp; exfalso...
    + destruct Hyp as [_ Hyp].
      pose proof (WfTypS l') as [Fwd Back]...
      destruct (Back v) as [T' [ValueV [TypingV BindsV]]]...
      exists T'...
      repeat split...
Qed.


Lemma typing_store_modify : forall E R s l e T,
  typing_store E R s ->
  Signatures.binds l (bind_sig T) R ->
  typing E R e T ->
  value e ->
  typing_store E R (LabelMapImpl.add l e s).
Proof with eauto using typing_weakening_sig_head, typing_store_free_store.
  intros E R s l e T WfTypS In Typ Val.
  intros l'.
  split; destruct (l' == l); subst...
  - intros T' Hyp; exists e; repeat split...
    LabelMapFacts.map_iff...
    enough (bind_sig T' = bind_sig T) as H; [inversion H|]...
    eapply Signatures.binds_unique...
  - intros T' Hyp; pose proof (WfTypS l') as [Fwd Back]...
    eapply Fwd in Hyp as [v [MapsTo [TypingV ValueV]]]...
    exists v; repeat split...
    LabelMapFacts.map_iff...
  - intros v.  LabelMapFacts.map_iff.
    intros Hyp. destruct Hyp as [Hyp | Hyp]...
    + destruct Hyp; subst...
    + destruct Hyp; exfalso...
  - intros v.  LabelMapFacts.map_iff.
    intros Hyp. destruct Hyp as [Hyp | Hyp]...
    + destruct Hyp; exfalso...
    + destruct Hyp as [_ Hyp].
      pose proof (WfTypS l') as [Fwd Back]...
Qed.


(* ********************************************************************** *)
(** ** Typing inversion (15) *)

Lemma something : forall E S1 S2 T,
  sub E (typ_int S1 S2) T ->
  (forall S1', in_intersection_component S1' (normal_form_typing S1) ->
    S1' = typ_top \/ (exists a U, S1' = typ_record a U) \/ (exists a U, S1' = typ_mut mut_readonly (typ_record a U))) ->
  (forall S2', in_intersection_component S2' (normal_form_typing S2) ->
    S2' = typ_top \/ (exists a U, S2' = typ_record a U) \/ (exists a U, S2' = typ_mut mut_readonly (typ_record a U))) ->
  (forall T', in_intersection_component T' (normal_form_typing T) ->
    T' = typ_top \/ (exists a U, T' = typ_record a U) \/ (exists a U, T' = typ_mut mut_readonly (typ_record a U))) ->
  (forall T', in_intersection_component T' (normal_form_typing T) ->
    (exists S1', in_intersection_component S1' (normal_form_typing S1) /\ sub E S1' T') \/
    (exists S2', in_intersection_component S2' (normal_form_typing S2) /\ sub E S2' T')).
Proof with subst; simpl in *; autorewrite with core in *; 
  eauto 4 using sub_reflexivity; repeat (fold merge_mutability in *; fold normal_form_typing in *);
  try discriminate.
  intros * Sub S1Comp S2Comp TComp.
  dependent induction Sub; intros T' [PrimT' IntT']...
  + inversion IntT'...
    unshelve epose proof (always_has_component (normal_form_typing S1)) as [S1' IntCompS1']...
    left. exists S1'... split...
    eapply sub_top; auto.
    eapply wf_typ_from_in_intersection with (T := normal_form_typing S1)...
    destruct IntCompS1'...
  + unshelve epose proof (in_intersection_merge _ _ _ _ IntT')
      as [Int | [T1' [EqT' IntT1']]]...
    * destruct IHSub with (S1 := S1) (S2 := S2) (T' := T')...
      (** invertying what is in T2 from TComp *)
      intros T2' IntCompT2.
      apply in_intersection_component_to_merge in IntCompT2...
      destruct IntCompT2 as [IntCompT2 | IntCompT2M]...
      destruct (TComp (merge_mutability T2' mut_readonly))
        as [BadEq | [[a [U BadEq]] | [a [U GoodEq]]]]...
      exfalso. eapply merge_mutability_inversion_record...
      eauto.
    * assert (in_normal_form (typ_mut mut_readonly T1')).
        eapply in_intersection_of_normal_is_normal with
          (T := merge_mutability (normal_form_typing T2) mut_readonly)...
      destruct IHSub with (S1 := S1) (S2 := S2) (T' := T1') as
        [[S1' [IntCompS1' SubS1']] | [S2' [IntCompS2' SubS2']]]; eauto...
      (** inverting what's in T2 from TComp *)
      intros T2' IntCompT2.
      apply in_intersection_component_to_merge in IntCompT2...
      destruct IntCompT2 as [IntCompT2 | IntCompT2M]...
      destruct (TComp (merge_mutability T2' mut_readonly))
        as [BadEq | [[a [U BadEq]] | [a [U GoodEq]]]]; eauto...
      exfalso. eapply merge_mutability_inversion_record...
      (** Making sure that T1' is not typ_int of something. *)
      constructor...
      intros [L [R Eq]]; subst. inversion H. 
  + destruct (TComp T') as [EqTop | [[a [U EqT]] | [a [U EqT]]]]; subst...
    * unshelve epose proof (always_has_component (normal_form_typing S1)) as [S1' IntCompS1']...
      left... exists S1'... split...
      (*** sub_top *)
      eapply sub_top; auto.
      eapply wf_typ_from_in_intersection with (T := normal_form_typing S1); auto.
      destruct IntCompS1'...
      apply wf_typ_normal_form.
      eapply wf_typ_int_left_from_wf_typ_int with (T2 := S2)...
    * unshelve epose proof (sub_canonical_record _ (typ_int S1 S2) T2 _ _) as CanT2...
      { 
        intros. destruct H as [Prim Int]. inversion Int; subst...
        exfalso. apply Prim...
      }
      unshelve epose proof (sub_inv_record _ _ _ _ _ IntT' Sub2)
        as [[X' EqX'] | [T2' [IntT2' [SubL SubR]]]]...
      - exfalso. destruct (CanT2 X') as 
          [BadTop | [[b'' [T'' BadEq]] | [b'' [T'' BadEq]]]]...
      - unshelve epose proof (sub_inv_record _ _ _ _ _ IntT2' Sub1)
          as [[X' EqX] | [S3 [IntS3 [SubL3 SubR3]]]]...
        -- inversion EqX; subst; try discriminate...
           exfalso. destruct (S1Comp X') as 
            [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
           exfalso. destruct (S2Comp X') as 
            [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
        -- inversion IntS3; subst; try discriminate...
           ++ left... exists (typ_record a S3)...
              split...
           ++ right... exists (typ_record a S3)...
              split...
    * unshelve epose proof (sub_canonical_record _ (typ_int S1 S2) T2 _ _) as CanT2...
    { 
      intros. destruct H as [Prim Int]. inversion Int; subst...
      exfalso. apply Prim...
    }
    unshelve epose proof (sub_inv_readonly_record _ _ _ _ _ _ Sub2)
      as [[X' EqX'] | [[X' EqX'] | [[T2' [IntT2' SubL]] | [T2' [IntT2' SubL]]]]]... 
    - exfalso. destruct (CanT2 X') as 
        [BadTop | [[b'' [T'' BadEq]] | [b'' [T'' BadEq]]]]...
    - exfalso. destruct (CanT2 (typ_mut mut_readonly X')) as 
        [BadTop | [[b'' [T'' BadEq]] | [b'' [T'' BadEq]]]]...
    - unshelve epose proof (sub_inv_record _ _ _ _ _ IntT2' Sub1)
        as [[X' EqX] | [S3 [IntS3 [SubL3 SubR3]]]]...
      -- inversion EqX; subst; try discriminate...
         exfalso. destruct (S1Comp X') as 
          [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
         exfalso. destruct (S2Comp X') as 
          [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
      -- inversion IntS3; subst; try discriminate...
         ++ left... exists (typ_record a S3)...
            split...
            eauto.
         ++ right... exists (typ_record a S3)...
            split...
            eauto.
    - unshelve epose proof (sub_inv_readonly_record _ _ _ _ _ _ Sub1)
        as  [[X' EqX] | [[X' EqX] | [[S3 [IntS3 SubL3]] | [S3 [IntS3 SubL3]]]]]...
        -- inversion EqX; subst; try discriminate...
           exfalso. destruct (S1Comp X') as 
            [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
           exfalso. destruct (S2Comp X') as 
            [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
        -- inversion EqX; subst; try discriminate...
           exfalso. destruct (S1Comp (typ_mut mut_readonly X')) as 
            [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...
           exfalso. destruct (S2Comp (typ_mut mut_readonly X')) as 
            [EqTop | [[b''' [T''' EqBad]] | [b''' [T''' EqBad]]]]...        
        -- inversion IntS3; subst; try discriminate...
            ++ left... exists (typ_record a S3)...
              split...
              eapply sub_transitivity with (Q := typ_mut mut_readonly (typ_record a S3))...
            ++ right... exists (typ_record a S3)...
              split...
              eapply sub_transitivity with (Q := typ_mut mut_readonly (typ_record a S3))...
        -- inversion IntS3; subst; try discriminate...
            ++ left... exists (typ_mut mut_readonly (typ_record a S3))...
              split...
            ++ right... exists (typ_mut mut_readonly (typ_record a S3))...
              split...
  + left; exists T'... split...
  + right; exists T'... split...
  + inversion IntT'...
    - exfalso...
    - destruct (IHSub1 S1 S2) with (T' := T'); auto 4.
      intros T2' [PrimT2' IntT2'].
      destruct (TComp T2'); auto 3.
      constructor...
    - destruct (IHSub2 S1 S2) with (T' := T'); auto 4.
      intros T3' [PrimT3' IntT3'].
      destruct (TComp T3'); auto 3.
      constructor...
  + edestruct IHSub with (S1 := normal_form_typing S1) (S2 := normal_form_typing S2)...
Qed.

Lemma typing_record_atom_free : forall E R r T (X : atom),
  typing_record_comp E R r T ->
  ~ in_intersection X (normal_form_typing T).
Proof with simpl in *; eauto; repeat (fold normal_form_typing in *; fold merge_mutability in *);
  try discriminate.
  intros * Typ.
  dependent induction Typ...
  - intro Bad; inversion Bad...
  - intro Bad; inversion Bad as [|A B C BadInt F|]; subst...
    inversion BadInt...
  - intro Bad; inversion Bad as [|A B C BadInt F|]; subst...
    inversion BadInt...
Qed.

Lemma typing_record_readonly_atom_free : forall E R r T (X : atom),
  typing_record_comp E R r T ->
  ~ in_intersection (typ_mut mut_readonly X) (normal_form_typing T).
Proof with simpl in *; eauto; repeat (fold normal_form_typing in *; fold merge_mutability in *);
  try discriminate.
  intros * Typ.
  dependent induction Typ...
  - intro Bad; inversion Bad...
  - intro Bad; inversion Bad as [|A B C BadInt F|]; subst...
    inversion BadInt...
  - intro Bad; inversion Bad as [|A B C BadInt F|]; subst...
    inversion BadInt...
Qed.

Lemma typing_record_fresh : forall E R r T (a a' : atom) S,
  a `notin` record_dom r ->
  typing_record_comp E R r T ->
  in_intersection_component (typ_record a' S) (normal_form_typing T) ->
  a <> a'.
Proof with simpl in *; eauto; repeat (fold normal_form_typing in *; fold merge_mutability in *);
  try discriminate.
  intros * Fresh Typ [Prim Int].
  dependent induction Typ...
  + exfalso; inversion Int...
  + destruct (a' === a0); subst...
    apply IHTyp... inversion Int
      as [|A B C IntBad F|]; subst...
    inversion IntBad as [A B Eq | |]; subst...
    inversion Eq; subst; exfalso...
  + destruct (a' === a0); subst...
    apply IHTyp... inversion Int
      as [|A B C IntBad F|]; subst...
    inversion IntBad as [A B Eq | |]; subst...
    inversion Eq; subst; exfalso...
Qed.

Lemma typing_record_only_records : forall E R r T S,
  typing_record_comp E R r T ->
  in_intersection_component S (normal_form_typing T) ->
  (S = typ_top) \/ (exists a U, S = typ_record a U).
Proof with simpl in *; eauto; repeat (fold normal_form_typing in *; fold merge_mutability in *);
try discriminate.
  intros * Typ [Prim Int]...
  dependent induction Typ...
  - inversion Int as [| A B C IntS F |]; subst...
    exfalso...
    inversion IntS...
  - inversion Int as [| A B C IntS F |]; subst...
    exfalso...
    inversion IntS...
Qed.

Lemma typing_record_readonly_record_free : forall E R r T (a : atom) S,
  typing_record_comp E R r T ->
  ~ in_intersection (typ_mut mut_readonly (typ_record a S)) (normal_form_typing T).
Proof with simpl in *; eauto; repeat (fold normal_form_typing in *; fold merge_mutability in *);
  try discriminate.
  intros * Typ.
  dependent induction Typ...
  - intro Bad; inversion Bad...
  - intro Bad; inversion Bad as [|A B C BadInt F|]; subst...
    inversion BadInt...
  - intro Bad; inversion Bad as [|A B C BadInt F|]; subst...
    inversion BadInt...
Qed.

Lemma typing_inv_record_ref : forall E R r a l T,
  typing_record_comp E R r T ->
  record_lookup_ref a r = Some l ->
  forall U, sub E T (typ_record a U) ->
    exists T', sub E T' U /\ sub E U T' /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; autorewrite with core in *; eauto using sub_inv_var;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *; try discriminate.
  intros E R r a l T Typ Ref.
  dependent induction Typ; intros U Sub; try discriminate...
  assert (wf_typ E T). {
    eapply wf_typ_from_wf_typ_record with (a := a0).
    eapply wf_typ_int_left_from_wf_typ_int with (T2 := Tr)...
  }
  assert (wf_typ E U). {
    apply wf_typ_from_wf_typ_record with (a := a)...
  }
  destruct (a == a0); subst...
  + inversion Ref; subst...
    unshelve epose proof 
      (something E (typ_record a0 T) Tr (typ_record a0 U) _ _ _ _ (typ_record a0 (normal_form_typing U)) _)
        as [[S1' [[PrimS1' IntS1'] SubS1']] | [S2' [[Prim Int] SubS2']]]...
    { 
      intros * [Prim S1Int].
      inversion S1Int as [A B Eq | |]; subst...
    }
    {
      intros * [Prim S2Int].
      unshelve epose proof 
        (typing_record_only_records _ _ _ Tr S2' _ _)
        as [EqTop | [a [U' Eq]]]...
    }
    {
      intros * [Prim TInt].
      inversion TInt as [A B Eq | |]; subst...
    }
    - inversion IntS1'; subst...
      unshelve epose proof (sub_inv_record _ _ _ (normal_form_typing U) _ _ SubS1')
        as [[X' BadInt] | [S2 [IntS2 [SubL SubR]]]]...
      * inversion BadInt; subst...
      * inversion IntS2 as [A B EqRec D | |]; subst... inversion EqRec; subst... exists T...
    - exfalso.
      unshelve epose proof (sub_inv_record _ _ a0 (normal_form_typing U)
        (typ_record a0 (normal_form_typing U)) _ _)
        as [[X' IntS'] | [S3 [IntS3 ?]]]...
      * inversion IntS' as [A B Eq D | A B C D EE Eq | A B C D EE Eq]; subst; try discriminate...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        eapply typing_record_atom_free...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *...
      * (** note that a not in r *)
        inversion IntS3 as [A B Eq D | A B C D EE Eq | A B C D EE Eq]; subst; try discriminate...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        eapply typing_record_fresh with (a := a0)...
        (** last two cases are just contradictions of S2 being not an intersection *)
        exfalso.
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        exfalso.
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
  + apply IHTyp...
    (** note that a is not in a0 *)
    unshelve epose proof 
    (something E (typ_record a0 T) Tr (typ_record a U) _ _ _ _ (typ_record a (normal_form_typing U)) _)
      as [[S1' [[PrimS1' IntS1'] SubS1']] | [S2' [[Prim Int] SubS2']]]...
    { 
      intros * [Prim S1Int].
      inversion S1Int as [A B Eq | |]; subst...
    }
    {
      intros * [Prim S2Int].
      unshelve epose proof 
        (typing_record_only_records _ _ _ Tr S2' _ _)
        as [EqTop | [a' [U' Eq]]]...
    }
    {
      intros * [Prim TInt].
      inversion TInt as [A B Eq | |]; subst...
    }
    * exfalso.
      inversion IntS1'; subst...
      unshelve epose proof (sub_inv_record _ _ a (normal_form_typing U)  (typ_record a (normal_form_typing U)) _ SubS1')
        as [[X' EqX'] | [S2' [IntS2' [SubL SubR]]]]...
      inversion EqX'...
      inversion IntS2' as [A B Eq D | |]; subst... inversion Eq...
    * apply sub_transitivity with (Q := S2')...
      eapply sub_in_intersection...
      eapply sub_normalize_right...
      eapply sub_reflexivity...
Qed.

Lemma typing_inv_record : forall E R r a l T,
  typing E R (exp_record r) T ->
  record_lookup_ref a r = Some l ->
  forall U, sub E T (typ_record a U) ->
    exists T', sub E T' U /\ sub E U T' /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; eauto using sub_inv_var;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros E R r a l T Typ Ref.
  dependent induction Typ; intros U Sub...
  Case "typing_sub".
    eapply typing_inv_record_ref...
Qed.

Lemma typing_inv_readonly_record_ref : forall E R r a l T,
  typing_record_comp E R r T ->
  record_lookup_ref a r = Some l ->
  forall U, sub E T (typ_mut mut_readonly (typ_record a U)) ->
    exists T', sub E T' U /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; autorewrite with core in *; eauto 4 using sub_inv_var;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *; try discriminate.
  intros E R r a l T Typ Ref.
  dependent induction Typ; intros U Sub; try discriminate...
  assert (wf_typ E T). {
    eapply wf_typ_from_wf_typ_record with (a := a0).
    eapply wf_typ_int_left_from_wf_typ_int with (T2 := Tr)...
  }
  assert (wf_typ E U). {
    apply wf_typ_from_wf_typ_readonly_record with (a := a)...
  }
  destruct (a == a0); subst...
  + inversion Ref; subst...
    unshelve epose proof 
      (something E (typ_record a0 T) Tr 
        (typ_mut mut_readonly (typ_record a0 U)) _ _ _ _
        (typ_mut mut_readonly (typ_record a0 (normal_form_typing U))) _)
        as [[S1' [[PrimS1' IntS1'] SubS1']] | [S2' [[Prim Int] SubS2']]]...
    { 
      intros * [Prim S1Int].
      inversion S1Int as [A B Eq | |]; subst...
      eauto.
    }
    {
      intros * [Prim S2Int].
      unshelve epose proof 
        (typing_record_only_records _ _ _ Tr S2' _ _)
        as [EqTop | [a [U' Eq]]]...
      eauto.
    }
    {
      intros * [Prim TInt].
      inversion TInt as [A B Eq | |]; subst...
      eauto.
    }
    - inversion IntS1'; subst...
      unshelve epose proof (sub_inv_readonly_record _ _ _ (normal_form_typing U) _ _ SubS1')
        as [[X' BadInt] | [[X' BadInt] | [[S2 [IntS2 SubL]] | [S2 [IntS2 SubL]]]]]...
      * inversion BadInt; subst...
      * inversion BadInt; subst...
      * inversion IntS2 as [A B EqRec D | |]; subst... inversion EqRec; subst...
      * inversion IntS2...
    - exfalso.
      unshelve epose proof (sub_inv_readonly_record _ _ a0 (normal_form_typing U)
        (typ_mut mut_readonly (typ_record a0 (normal_form_typing U))) _ _)
        as [[X' IntS'] | [[X' IntS'] | [[S3 [IntS3 ?]] | [S3 [IntS3 ?]]]]]...
      * inversion IntS' as [A B Eq D | A B C D EE Eq | A B C D EE Eq]; subst; try discriminate...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        eapply typing_record_atom_free...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *...
      * inversion IntS' as [A B Eq D | A B C D EE Eq | A B C D EE Eq]; subst; try discriminate...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        eapply typing_record_readonly_atom_free with (X := X')...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *...
      * (** a is fresh *)
        inversion IntS3 as [A B Eq D | A B C D EE Eq | A B C D EE Eq]; subst; try discriminate...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        eapply typing_record_fresh with (a := a0)...
        (** last two cases are just contradictions of S2 being not an intersection *)
        exfalso.
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        exfalso.
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...        
      * (* we can't get readonly record types here *)
        inversion IntS3 as [A B Eq D | A B C D EE Eq | A B C D EE Eq]; subst; try discriminate...
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        eapply typing_record_readonly_record_free...
        (** last two cases are just contradictions of S2 being not an intersection *)
        exfalso.
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
        exfalso.
        unshelve epose proof (normal_form_unique S2' _) as S2Eq...
        assert (in_normal_form S2') as S2'Norm.
          eapply intersection_of_normal_is_normal with (T := normal_form_typing Tr); eauto 4.
          eapply normal_forms; auto.
          eapply type_from_wf_typ with (E := E)...
        rewrite <- (S2Eq S2'Norm) in *; subst...
  + apply IHTyp...
    (** note that a is not in a0 *)
    unshelve epose proof (something E (typ_record a0 T) Tr 
                          (typ_mut mut_readonly (typ_record a U)) _ _ _ _
                          (typ_mut mut_readonly (typ_record a (normal_form_typing U))) _)
      as [[S1' [[PrimS1' IntS1'] SubS1']] | [S2' [[Prim Int] SubS2']]]...
    { 
      intros * [Prim S1Int].
      inversion S1Int as [A B Eq | |]; subst...
      eauto.
    }
    {
      intros * [Prim S2Int].
      unshelve epose proof 
        (typing_record_only_records _ _ _ Tr S2' _ _)
        as [EqTop | [a' [U' Eq]]]...
      eauto.
    }
    {
      intros * [Prim TInt].
      inversion TInt as [A B Eq | |]; subst...
      eauto.
    }
    * exfalso.
      inversion IntS1'; subst...
      unshelve epose proof (sub_inv_readonly_record _ _ a (normal_form_typing U) _ _ SubS1')
        as [[X' EqX'] | [[X' EqX'] | [[S2' [IntS2' SubL]] | [S2' [IntS2' SubL]]]]]...
      inversion EqX'...
      inversion EqX'...
      inversion IntS2' as [A B Eq D | |]; subst... inversion Eq...
      inversion IntS2' as [A B Eq D | |]; subst...
    * apply sub_transitivity with (Q := S2')...
      eapply sub_in_intersection...
      eapply sub_normalize_right...
      eapply sub_reflexivity...
Qed.


Lemma typing_inv_readonly_record : forall E R r a l T,
  typing E R (exp_record r) T ->
  record_lookup_ref a r = Some l ->
  forall U, sub E T (typ_mut mut_readonly (typ_record a U)) ->
    exists T', sub E T' U  /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; eauto 4 using sub_inv_var;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros E R r a l T Typ Ref.
  dependent induction Typ; intros U Sub...
  Case "typing_sub".
    eapply typing_inv_readonly_record_ref...
Qed.

Lemma typing_inv_sealed_readonly_record : forall E R r a l T,
  typing E R (exp_seal (exp_record r)) T ->
  record_lookup_ref a r = Some l ->
  forall U, sub E T (typ_mut mut_readonly (typ_record a U)) ->
    exists T', sub E T' U /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; eauto 4 using sub_inv_var, sub_reflexivity;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros E R r a l T Typ Ref.
  dependent induction Typ; intros U Sub...
  Case "typing_sub".
    assert (typing E R (exp_record r) (typ_mut mut_readonly T)) as Typ'.
      eapply typing_sub...
    unshelve epose proof (typing_inv_readonly_record _ _ _ _ _ _ Typ' _ _ Sub)...
Qed.

Lemma typing_inv_abs : forall E R S1 e1 T,
  typing E R (exp_abs S1 e1) T ->
  forall U1 U2, sub E T (typ_arrow U1 U2) ->
     sub E U1 S1
  /\ exists S2, exists L, forall x, x `notin` L ->
     typing (x ~ bind_typ S1 ++ E) R (open_ee e1 x) S2 /\ sub E S2 U2.
Proof with simpl in *; eauto using sub_inv_var, sub_reflexivity;
  repeat (fold merge_mutability in *; fold normal_form_typing in *).
  intros E R S1 e1 T Typ.
  dependent induction Typ; intros U1 U2 Sub...

  (** Some facts to make automation work *)
  assert (wf_typ E (typ_arrow U1 U2))...
  assert (type U1). {
    eapply type_from_wf_typ with (E := E)...
  }
  assert (type U2). {
    eapply type_from_wf_typ with (E := E)...
  }

  assert (wf_typ E (typ_arrow S1 T1))...
  assert (type S1). {
    eapply type_from_wf_typ with (E := E)...
  }
  assert (type T1). {
    eapply type_from_wf_typ with (E := E)...
  }

  Case "typing_sub".
    unshelve 
      epose proof 
        (sub_inv_arrow E 
          (typ_arrow S1 T1) 
          (normal_form_typing U1) 
          (normal_form_typing U2)
          (typ_arrow (normal_form_typing U1) (normal_form_typing U2))
          _ _) as InvSub...
    autorewrite with core...
    eapply sub_transitivity; [exact Sub|]; apply sub_arrow...
    destruct InvSub as [[S' BadS'] | [[S' BadS'] | GoodCase]]...
    - inversion BadS'; subst; discriminate...
    - inversion BadS'; subst; discriminate...
    - destruct GoodCase as [S3 [S2 [NormS3 [NormS2 [IntS3S2 [SubS3 SubS2]]]]]]...
      inversion IntS3S2 as [S T EqArr EqS EqT | |]; subst...
      inversion EqArr; subst...
      split...
      + exists T1. exists L...
        intros x Fr...
        split...
Qed.

Lemma typing_inv_tabs : forall E R S1 e1 T,
  typing E R (exp_tabs S1 e1) T ->
  forall U1 U2, sub E T (typ_all U1 U2) ->
     sub E U1 S1
  /\ exists S2, exists L, forall X, X `notin` L ->
     typing (X ~ bind_sub U1 ++ E) R (open_te e1 X) (open_tt S2 X)
     /\ sub (X ~ bind_sub U1 ++ E) (open_tt S2 X) (open_tt U2 X).
Proof with simpl in *; eauto using sub_inv_var, sub_reflexivity;
  repeat (fold merge_mutability in *; fold normal_form_typing in *); simpl_env.
  intros E R S1 e1 T Typ.
  dependent induction Typ; intros U1 U2 Sub...

  (** Some facts to make automation work *)
  assert (wf_typ E (typ_all U1 U2)) as WfTypAllU1U2...
  assert (type U1). {
    eapply type_from_wf_typ with (E := E)...
  }
  assert (wf_typ E (typ_all S1 T1)) as WfTypAllS1T1...
  assert (type S1). {
    eapply type_from_wf_typ with (E := E)...
  }

  Case "typing_sub".
    unshelve epose proof
      (sub_inv_all E (typ_all S1 T1) 
        (normal_form_typing U1)
        (normal_form_typing U2)
        (normal_form_typing (typ_all U1 U2))
        _
        _
      ) as InvSub...
    autorewrite with core...
    eapply sub_transitivity; [exact Sub|]; apply sub_all with (L := L `union` dom E)...
      intros X Fr...
      rewrite <- normal_form_open_tt...
      eapply sub_normalize_right... eapply sub_reflexivity...
      econstructor...
      eapply wf_typ_open with (T1 := U1); eauto 4.
      eapply wf_typ_weaken_head...

    destruct InvSub as [[S' BadS'] | [[S' BadS'] | GoodCase]]...
    - inversion BadS'; subst; discriminate...
    - inversion BadS'; subst; discriminate...
    - destruct GoodCase as [L' [S2 [S3 [NormS2 [IntS2S3 [SubS2 SubS3]]]]]]...
      inversion IntS2S3 as [S T EqAll EqS EqT | |]; subst...
      inversion EqAll; subst...
      split...
      + exists T1; exists (L' `union` L)...
        intros X Fr...
        split...
        * rewrite_env (empty ++ X ~ bind_sub U1 ++ E).
          eapply typing_narrowing with (Q := S1)...
        * unshelve epose proof (SubS3 X _) as [NormOpen OpenSub]...
          repeat rewrite <- normal_form_open_tt in OpenSub...
          rewrite_env (empty ++ X ~ bind_sub U1 ++ E).
          eapply sub_narrowing with (Q := normal_form_typing U1)...
          eapply sub_transitivity with (Q := normal_form_typing (open_tt T1 X))...
          eapply sub_normalize_right; eapply sub_reflexivity; auto.
            eapply wf_typ_open with (T1 := S1)...
            eapply wf_typ_weaken_head; auto...
          eapply sub_transitivity with (Q := normal_form_typing (open_tt U2 X))...
          eapply sub_normalize_left; eapply sub_reflexivity; auto.
            eapply wf_typ_open with (T1 := U1); eauto 4.
            eapply wf_typ_weaken_head; auto...
Qed.

Lemma typing_inv_ref : forall E R l T,
  typing E R (exp_ref l) T ->
  forall U, sub E T (typ_box U) ->
    exists T', sub E T' U /\ sub E U T' /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; eauto using sub_inv_var;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros E R l T Typ.
  dependent induction Typ; intros U Sub...
  Case "typing_sub".
    unshelve epose proof 
      (sub_inv_ref _ (typ_box T) (normal_form_typing U) _ _ Sub)
      as InvSub...
    destruct InvSub as [[S' IntS'] | [S1 [IntS1 [SubS1L SubS1R]]]]...
    - exfalso... inversion IntS'; subst... discriminate.
    - inversion IntS1 as [S2 T2 EqS1 | |]; subst...
      inversion EqS1; simpl in *; subst...
      exists T... repeat split...
Qed.

Lemma typing_inv_readonly_ref : forall E R l T,
  typing E R (exp_ref l) T ->
  forall U, sub E T (typ_mut mut_readonly (typ_box U)) ->
    exists T', sub E T' U /\ sub E U T' /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; eauto using sub_inv_var;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros E R l T Typ.
  dependent induction Typ; intros U Sub...
  Case "typing_sub".
    unshelve epose proof 
      (sub_inv_readonly_ref _ (typ_box T) (normal_form_typing U) _ _ Sub)
      as InvSub...
    destruct InvSub as [
      [S' IntS'] 
      | [[S' IntS'RO] 
      | [[S1 [IntS1 [SubS1L SubS1R]]]
      |  [S1 [IntS1RO [SubS1L SubS1R]]]]]]...
    + exfalso... inversion IntS'; subst... discriminate.
    + exfalso... inversion IntS'RO; subst... discriminate.
    + inversion IntS1 as [S2 T2 EqS1 | |]; subst...
      inversion EqS1; simpl in *; subst...
      exists T... repeat split...
    + exfalso... inversion IntS1RO; subst... discriminate.
Qed.


Lemma typing_inv_sealed_readonly_ref : forall E R l T,
  typing E R (exp_seal (exp_ref l)) T ->
  forall U, sub E T (typ_mut mut_readonly (typ_box U)) ->
    exists T', sub E T' U /\ sub E U T' /\ Signatures.binds l (bind_sig T') R.
Proof with simpl in *; simpl_env; eauto using sub_inv_var, sub_reflexivity;
  repeat fold merge_mutability in *; repeat fold normal_form_typing in *.
  intros E R l T Typ.
  dependent induction Typ; intros U Sub...
  Case "typing_sub".
    assert (typing E R (exp_ref l) (typ_mut mut_readonly T)) as Typ'.
      eapply typing_sub...
    unshelve epose proof (typing_inv_readonly_ref _ _ _ _ Typ' _ Sub)...
Qed.

(* ********************************************************************** *)
(** ** Preservation (20) *)

Lemma red_record_comp_preserves_labels : forall a r s r' s',
  a `notin` record_dom r ->
  red_record_comp r s r' s' ->
  a `notin` record_dom r'.
Proof with eauto.
  intros * Fr Red.
  induction Red; simpl in *...
Qed.
#[export] Hint Resolve red_record_comp_preserves_labels : core.

Lemma preservation : forall E R e s e' s' T,
  typing E R e T ->
  typing_store E R s ->
  red e s e' s' ->
  exists R', wf_sig E (R' ++ R) /\ 
    typing E (R' ++ R) e' T /\
    typing_store E (R' ++ R) s'
with preservation_record : forall E R r s r' s' T,
  typing_record_comp E R r T ->
  typing_store E R s ->
  red_record_comp r s r' s' ->
  exists R', wf_sig E (R' ++ R) /\
    typing_record_comp E (R' ++ R) r' T /\
    typing_store E (R' ++ R) s'.
Proof with simpl_env; eauto 5 using typing_record_weakening_sig_head, typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity.
------
  clear preservation.
  intros E R e s e' s' T Typ TypS. generalize dependent e'. generalize dependent s'.
  induction Typ; intros s' e' Red; 
    try solve [ inversion Red;
      destruct (IHTyp TypS s' e') as [Re' [WfR' [TypingR StoreR]]]; subst;
      simpl_env; eauto using typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity ]; 
    try solve [ inversion Red;
      destruct (IHTyp TypS s' e1') as [Re1' [WfR1' [TypingR1 StoreR1]]]; subst;
      simpl_env; eauto using typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity ].
  Case "typing_app". 
    inversion Red; subst;
      try destruct (IHTyp1 TypS s' e1') as [Re1' [WfR1' [TypingR1 StoreR1]]];
      try destruct (IHTyp2 TypS s' e2') as [Re2' [WfR2' [TypingR2 StoreR2]]];
      try solve [exists Re1'; simpl_env; eauto using typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity];
      try solve [exists Re2'; simpl_env; eauto using typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity]...
    SCase "red_abs".
      destruct (typing_inv_abs _ _ _ _ _ Typ1 T1 T2) as [P1 [S2 [L P2]]]...
       exists sempty; simpl_sig; split...
      split...
      pick fresh x.
      destruct (P2 x) as [? ?]...
      rewrite (subst_ee_intro x)...
      rewrite_env (empty ++ E).
      apply (typing_through_subst_ee T).
        apply (typing_sub S2)...
          rewrite_env (empty ++ x ~ bind_typ T ++ E);
          apply sub_weakening...
        eauto.
  Case "typing_tapp".
    inversion Red; subst;
      try specialize (IHTyp TypS s' e1') as [Re1' [WfR1' [TypingR1 StoreR1]]];
        eauto...
    SCase "red_tabs".
      destruct (typing_inv_tabs _ _ _ _ _ Typ T1 T2) as [P1 [S2 [L P2]]]...
      exists sempty; simpl_sig; split...
      split...
      pick fresh X.
      destruct (P2 X) as [? ?]...
      rewrite (subst_te_intro X)...
      rewrite (subst_tt_intro X)...
      rewrite_env (map (subst_tb X T) empty ++ E).
      apply (typing_through_subst_te T1)...
  Case "typing_let".
    inversion Red; subst; eauto...
    SCase "red_let_1".
      specialize (IHTyp TypS s' e1') as [Re1' [WfRe1' [TypingR1 StoreR1]]]...
      exists Re1'; split...
      split...
      pick fresh x and apply typing_let...
    SCase "red_let".
      pick fresh x.
      exists sempty; split...
      split...
      rewrite (subst_ee_intro x)...
      rewrite_env (empty ++ E).
      apply (typing_through_subst_ee T1)...
  Case "typing_box".
    inversion Red; subst...
    SCase "red_box_1".
      specialize (IHTyp TypS s' e1') as [Re' [WfRe1' [TypingR1 StoreR1]]]...
    SCase "red_box_ref".
      set (l := (fresh_label_for_store s)).
      unshelve epose proof (proj2_sig (exists_fresh_label_for_store s))...
      assert (wf_sig E ((l ~ bind_sig T) ++ R)).
        constructor...
        eapply typing_store_free_store...
      exists (l ~ bind_sig T); split...
      split...
      apply typing_store_add...
  Case "typing_unbox".
    inversion Red; subst...
    SCase "red_unbox_1".
      specialize (IHTyp TypS s' e1') as [Re' [WfRe1' [TypingR1 StoreR1]]]...
    SCase "red_unbox_ref".
      exists sempty; simpl_sig; split...
      destruct (typing_inv_ref _ _ _ _ Typ T) as [U [Sub1 [Sub2 Binds]]]...
      split...
      destruct (TypS l) as [_ MapsTo].
      destruct (MapsTo e') as [T' [ValueV [TypingV BindsV]]]...
      replace T' with U in *...
      enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
      eapply Signatures.binds_unique...
    SCase "red_unbox_sealed_ref".
      exfalso...
      unshelve epose proof (typing_canonical_sealed_ref _ _ _ _ Typ (typ_box (normal_form_typing T)) _) as [EqTop | [U1 EqReadBox]]...
      discriminate.
      discriminate.
  Case "typing_set_box".
    inversion Red; subst...
    SCase "red_set_box_1".
      specialize (IHTyp1 TypS s' e1') as [Re' [WfRe' [TypingR1 Store1]]]...
      exists Re'...
    SCase "red_set_box_2".
      specialize (IHTyp2 TypS s' e2') as [Re' [WfRe2' [TypingR2 StoreR2]]]...
      exists Re'...
    SCase "red_set_box_ref".
      exists sempty; simpl_sig; subst; split...
      split...
      destruct (typing_inv_ref _ _ _ _ Typ1 T) as [U [Sub1 [Sub2 Binds]]]...
        destruct (TypS l) as [_ MapsTo].
        destruct (MapsTo e') as [T' [ValueV [TypingV BindsV]]]...
        replace T' with U in *...
        enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
        eapply Signatures.binds_unique...
      destruct ((proj2 (TypS l)) e') as [T' [ValueE' [TypingE' BindsE']]]...
        pose proof (typing_inv_ref _ _ _ _  Typ1).
        destruct (typing_inv_ref _ _ _ _ Typ1 T) as [U [Sub1 [Sub2 Binds]]]...
        eapply typing_store_modify with (T := U)...
  Case "typing_seal".
    inversion Red; subst...
    SCase "red_seal_1".
      destruct (IHTyp TypS s' e1') as [Re' [WfRe1' [TypingR1 StoreR1]]]...
    SCase "red_seal_abs".
      exists sempty; repeat (split; eauto 6 using typing_weakening_sig_head, wf_sig_weaken_head)...
    SCase "red_seal_tabs".
      exists sempty; repeat (split; eauto 6 using typing_weakening_sig_head, wf_sig_weaken_head)...
    SCase "red_seal_ref".
      exists sempty; repeat (split; eauto 6 using typing_weakening_sig_head, wf_sig_weaken_head)...
    SCase "red_seal_record".
      exists sempty. repeat (split; eauto 6 using typing_weakening_sig_head, wf_sig_weaken_head)...
  Case "typing_unbox_readonly".
    inversion Red; subst...
    SCase "red_unbox_1".
      destruct (IHTyp TypS s' e1') as [Re' [WfRe1' [TypingR1 StoreR1]]]...
    SCase "red_unbox_ref".
      exists sempty; simpl_sig; split...
      destruct (typing_inv_readonly_ref _ _ _ _ Typ T) as [U [Sub1 [Sub2 Binds]]]...
      split...
      destruct (TypS l) as [_ MapsTo].
      destruct (MapsTo e') as [T' [ValueV [TypingV BindsV]]]...
      replace T' with U in *...
      enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
      eapply Signatures.binds_unique...
    SCase "red_unbox_sealed_ref".
      exists sempty; simpl_sig; split...
      destruct (typing_inv_sealed_readonly_ref _ _ _ _ Typ T) as [U [Sub1 [Sub2 Binds]]]...
      split...
      destruct (TypS l) as [_ MapsTo].
      destruct (MapsTo v1) as [T' [ValueV [TypingV BindsV]]]...
      replace T' with U in *...
      enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
      eapply Signatures.binds_unique...
  Case "typing_record".
    inversion Red; subst...
    unshelve epose proof
      (preservation_record E R r s r1' s' T _ _ _) as
      [R' [WfSig [TypRecRed TypSRed]]]...
  Case "typing_record_read".
    inversion Red; subst...
    SCase "red_record_read_1".
      destruct (IHTyp TypS s' e1') as [Re' [WfRe1' [TypingR1 StoreR1]]]...
    SCase "red_record_read_label".
      exists sempty; simpl_sig; split...
      unshelve epose proof (typing_inv_record _ _ _ _ _ _ Typ _)
        as [U [Sub1 [Sub2 Binds]]]...
      split...
      destruct (TypS l) as [_ MapsTo].
      destruct (MapsTo e') as [T' [ValueV [TypingV BindsV]]]...
      replace T' with U in *...
      enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
      eapply Signatures.binds_unique...
    SCase "red_record_read_sealed_label".
      exfalso...
      unshelve epose proof (typing_canonical_sealed_record _ _ _ _ Typ
        (typ_record a (normal_form_typing T)) _) as [EqTop | [a' [U1 EqReadBox]]];
          try discriminate...
  Case "typing_record_red_readonly".
    inversion Red; subst...
    SCase "red_record_read_1".
      destruct (IHTyp TypS s' e1') as [Re' [WfRe1' [TypingR1 StoreR1]]]...
    SCase "red_record_read_label".
      exists sempty; simpl_sig; split...
      unshelve epose proof (typing_inv_readonly_record _ _ _ _ _ _ Typ _)
        as [U [Sub1 Binds]]...
      split...
      destruct (TypS l) as [_ MapsTo].
      destruct (MapsTo e') as [T' [ValueV [TypingV BindsV]]]...
      replace T' with U in *...
      enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
      eapply Signatures.binds_unique...
    SCase "red_record_read_sealed_label".
      exists sempty; simpl_sig; split...
      unshelve epose proof (typing_inv_sealed_readonly_record _ _ _ _ _ _ Typ _)
        as [U [Sub1 Binds]]...
      split...
      destruct (TypS l) as [_ MapsTo].
      destruct (MapsTo v1) as [T' [ValueV [TypingV BindsV]]]...
      replace T' with U in *...
      enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
      eapply Signatures.binds_unique...
  Case "typing_record_write".
    inversion Red; subst...
    SCase "red_record_write_1".
      specialize (IHTyp1 TypS s' e1') as [Re' [WfRe' [TypingR1 Store1]]]...
      exists Re'...
    SCase "red_record_write_2".
      specialize (IHTyp2 TypS s' e2') as [Re' [WfRe2' [TypingR2 StoreR2]]]...
      exists Re'...
    SCase "red_record_write_ref".
      exists sempty; simpl_sig; subst; split...
      split...
      unshelve epose proof (typing_inv_record _ _ _ a l _ Typ1 _ T) as [U [Sub1 [Sub2 Binds]]]...
        destruct (TypS l) as [_ MapsTo].
        destruct (MapsTo e') as [T' [ValueV [TypingV BindsV]]]...
        replace T' with U in *...
        enough ((bind_sig U) = (bind_sig T')) as Con. inversion Con...
        eapply Signatures.binds_unique...
      destruct ((proj2 (TypS l)) e') as [T' [ValueE' [TypingE' BindsE']]]...
        destruct (typing_inv_record _ _ _ _ _ _ Typ1 H4 T) as [U [Sub1 [Sub2 Binds]]]...
        eapply typing_store_modify with (T := U)...
------
  clear preservation_record.
  intros E R r s r' s' T Typ TypS. generalize dependent r'. generalize dependent s'.
  induction Typ; intros s' e' Red; 
    try solve [ inversion Red;
      destruct (IHTyp TypS s' r') as [Rr' [WfR' [TypingR StoreR]]]; subst;
      simpl_env; eauto using typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity ]; 
    try solve [ inversion Red;
      destruct (IHTyp TypS s' r1') as [Rr1' [WfR1' [TypingR1 StoreR1]]]; subst;
      simpl_env; eauto using typing_weakening_sig_head, wf_sig_weaken_head, sub_reflexivity ].

  Case "typing_record_exp".
    inversion Red; subst...
    SCase "red_record_exp_1".
      unshelve epose proof
        (preservation E R e s e1' s' T _ _ _) as
        [R' [WfSig [TypERed TypSRed]]]...
      exists R'... repeat (split; eauto 6 using typing_record_weakening_sig_head, wf_sig_weaken_head)...
    SCase "red_record_exp_2".
      set (l := (fresh_label_for_store s)).
      unshelve epose proof (proj2_sig (exists_fresh_label_for_store s))...
      assert (wf_sig E ((l ~ bind_sig T) ++ R)).
        constructor...
        eapply typing_store_free_store...
      exists (l ~ bind_sig T); split...
      split...
      apply typing_store_add...
  Case "typing_record_ref".
    inversion Red; subst...
    destruct (IHTyp TypS s' r1') as [Rr1' [WfR1' [TypingR1 StoreR1]]]...
    exists Rr1'; split...
Qed.


(* ********************************************************************** *)
(** * #<a name="progress"></a># Progress *)


(* ********************************************************************** *)
(** ** Canonical forms (14) *)

Lemma merge_mutability_inversion_arrow_simpl : forall T T1 T2,
  typ_arrow T1 T2 =  merge_mutability T mut_readonly ->
  exists T1 T2, T = typ_arrow T1 T2.
Proof with simpl in *; eauto; try discriminate; repeat fold merge_mutability in *.
  intros * Merge.
  induction T...
Qed.
#[export] Hint Resolve merge_mutability_inversion_arrow_simpl : core.

Lemma merge_mutability_inversion_readonly_arrow_simpl : forall T T1 T2,
  typ_mut mut_readonly (typ_arrow T1 T2) =  merge_mutability T mut_readonly ->
  (exists T1 T2, T = typ_arrow T1 T2) \/ (exists T1 T2, T = typ_mut mut_readonly (typ_arrow T1 T2)).
Proof with simpl in *; eauto; try discriminate; repeat fold merge_mutability in *.
  intros * Merge.
  induction T...
Qed.
#[export] Hint Resolve merge_mutability_inversion_readonly_arrow_simpl : core.

Lemma canonical_form_abs_rec : forall e R T,
  value e ->
  typing empty R e T ->
  (exists U1 U2, in_intersection_component (typ_arrow U1 U2) (normal_form_typing T))->
  exists V, exists e1, e = (exp_abs V e1).
Proof with simpl in *; eauto 4; repeat fold merge_mutability in *; repeat fold normal_form_typing in*.
  intros * Val Typ ExistsArrowTyp.
  dependent induction Typ;
    destruct ExistsArrowTyp as [U1 [U2 IntComp]];
    try solve [inversion Val; inversion IntComp as [Prim Int]; inversion Int; eauto; try discriminate]...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int].
    unshelve epose proof (sub_inv_arrow empty S U1 U2 T _ _) as 
      [[X EqX] | 
      [[X EqRX] | 
      [S1 [S2 [NormS1 [NormS2 [IntS1S2 [SubL SubR]]]]]]]]...
    * assert (wf_typ empty X) as Contra2...
      inversion Contra2; subst...
      analyze_binds H3...
    * assert (wf_typ empty (typ_mut mut_readonly X)) as Contra2...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3; subst...
      analyze_binds H3...
    * exists S1...
  - inversion Val; subst...
    inversion IntComp as [Prim Int]...
    unshelve epose proof (in_intersection_arrow_merge_in_normal _ _ _ Int _).
      apply normal_forms. apply type_from_wf_typ with (E := empty)...
      destruct IHTyp as [V [e1 Eq]]...  
      exists U1...
      discriminate.
    exfalso...
      apply in_intersection_component_inversion_merge in IntComp
        as [Arrow [IntArrow EqArrow]]...
      apply merge_mutability_inversion_arrow_simpl in EqArrow as [T1' [T2' Eq']]; subst...
      unshelve epose proof (typing_canonical_record _ _ _ _ Typ _ IntArrow)
        as [BadTop | [[a [U3 BadRecU3]] | [a [U3 BadRecU3]]]]; try discriminate...
  - exfalso...
    unshelve epose proof (typing_canonical_record_rec _ _ _ _ H _ IntComp)
      as [BadTop | [a [U3 BadRecU3]]]; try discriminate...
Qed.

Lemma canonical_form_abs : forall e R U1 U2,
  value e ->
  typing empty R e (typ_arrow U1 U2) ->
  exists V, exists e1, e = exp_abs V e1.
Proof with eauto.
  intros e R U1 U2 Val Typ.
  remember (typ_arrow U1 U2) as T.
  assert
    (in_intersection_component (normal_form_typing (typ_arrow U1 U2)) (normal_form_typing T)) as IntCompT...
    split...
    subst...
  clear HeqT.
  eapply canonical_form_abs_rec...
Qed.

Lemma canonical_form_tabs_rec : forall e R T,
  value e ->
  typing empty R e T ->
  (exists U1 U2, in_intersection_component (typ_all U1 U2) (normal_form_typing T)) ->
  exists V, exists e1, e = (exp_tabs V e1).
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in*.
  intros * Val Typ ExistsArrowTyp.
  dependent induction Typ;
    destruct ExistsArrowTyp as [U1 [U2 IntComp]];
    try solve [inversion Val; inversion IntComp as [Prim Int]; inversion Int; eauto; try discriminate]...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int].
    unshelve epose proof (sub_inv_all empty S U1 U2 T _) as 
      [[X EqX] | 
      [[X EqRX] | 
      [L [S1 [S2 [NormS1 [NormS2 [IntS1S2 Sub]]]]]]]]...
    * assert (wf_typ empty X) as Contra2...
      inversion Contra2; subst...
      analyze_binds H3...
    * assert (wf_typ empty (typ_mut mut_readonly X)) as Contra2...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3; subst...
      analyze_binds H3...
  - inversion Val; subst...
      exfalso...
      inversion IntComp as [Prim Int]...
      unshelve epose proof (in_intersection_all_merge_in_normal _ _ _ Int _).
      apply normal_forms. apply type_from_wf_typ with (E := empty)...
      destruct IHTyp as [V [e1 Eq]]...
      discriminate.

      exfalso...
      inversion IntComp as [Prim Int]...
      unshelve epose proof (in_intersection_all_merge_in_normal _ _ _ Int _).
      apply normal_forms. apply type_from_wf_typ with (E := empty)...
      destruct IHTyp as [V [e1 Eq]]... 
      discriminate.
  - exfalso...
    unshelve epose proof (typing_canonical_record_rec _ _ _ _ H _ IntComp)
      as [BadTop | [a [U3 BadRecU3]]]; try discriminate...
Qed.

Lemma canonical_form_tabs : forall e R U1 U2,
  value e ->
  typing empty R e (typ_all U1 U2) ->
  exists V, exists e1, e = exp_tabs V e1.
Proof with eauto.
  intros e R U1 U2 Val Typ.
  remember (typ_all U1 U2) as T.
  assert
    (in_intersection_component (normal_form_typing (typ_all U1 U2)) (normal_form_typing T)) as IntCompT...
    split...
    subst...
  clear HeqT.
  eapply canonical_form_tabs_rec...   
Qed.

Lemma canonical_form_ref_rec : forall e R T,
  value e ->
  typing empty R e T ->
  (exists U1, in_intersection_component (typ_box U1) (normal_form_typing T)) ->
  exists l, e = exp_ref l.
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in*.
  intros e R U1 Val Typ ExistsBoxTyp.
  dependent induction Typ;
    destruct ExistsBoxTyp as [U1 IntComp];
    try solve [inversion Val; inversion IntComp as [Prim Int]; inversion Int; eauto; try discriminate]...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int]...
    unshelve epose proof 
      (sub_inv_ref empty _ U1 T
       _ H0) as [[X IntX] | [S1 [IntS1 [SubL SubR]]]]...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
  - inversion Val; subst...
    inversion IntComp as [Prim Int]...
    exfalso...
    eapply merge_mutability_inversion_box_intersection in Int...

    inversion Val; subst...
    inversion IntComp as [Prim Int]...
    exfalso...
    eapply merge_mutability_inversion_box_intersection in Int...
  - exfalso.
    unshelve epose proof (typing_canonical_record_rec _ _ _ _ H _ IntComp)
    as [BadTop | [a [U3 BadRecU3]]]; try discriminate...
Qed.
Lemma canonical_form_ref : forall e R U1,
  value e ->
  typing empty R e (typ_box U1) ->
  exists l, e = exp_ref l.
Proof with eauto.
  intros e R U1 Val Typ.
  eapply canonical_form_ref_rec...
  exists (normal_form_typing U1)...
Qed.


Lemma canonical_form_readonly_ref_rec : forall e R T,
  value e ->
  typing empty R e T ->
  ((exists U1, in_intersection_component (typ_box U1) (normal_form_typing T)) \/
   (exists U1, in_intersection_component (typ_mut mut_readonly (typ_box U1))
     (normal_form_typing T))
  ) ->
  (exists l, e = exp_ref l) \/ (exists l, e = exp_seal (exp_ref l)).
Proof with simpl in *; eauto 4; repeat fold merge_mutability in *; repeat fold normal_form_typing in*.
  intros e R U1 Val Typ ExistsBoxTyp.
  dependent induction Typ;
    destruct ExistsBoxTyp as [[U1 IntComp] | [U1 IntComp]];
    try solve [inversion Val; inversion IntComp as [Prim Int]; inversion Int; eauto; try discriminate]...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int]...
    unshelve epose proof 
      (sub_inv_readonly_ref empty _ U1 T
       _ H0) as
       [[X IntX] | 
        [[X IntROX] |
         [[S1 [IntS1 [SubL SubR]]] |
         [S1 [IntS1RO [SubL SubR]]]]]]...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + left...
    + right...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int]...
    unshelve epose proof 
      (sub_inv_readonly_ref empty _ U1 T
      _ H0) as
      [[X IntX] | 
        [[X IntROX] |
        [[S1 [IntS1 [SubL SubR]]] |
        [S1 [IntS1RO [SubL SubR]]]]]]...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + left...
    + right...
  - inversion Val; inversion IntComp as [Prim Int]; eauto; subst...
    exfalso.
    apply in_intersection_box_merge_in_normal in Int...
    unshelve epose proof (typing_canonical_record _ _ _ _ Typ (typ_box U1) _)
      as [BadTop | [[a [U2 BadRec]] | [a [U2 BadRec]]]]; try discriminate...
  - inversion Val; inversion IntComp as [Prim Int]; eauto; subst...
    exfalso.
    apply in_intersection_readonly_box_merge_in_normal in Int as [Int | IntRO]...
    unshelve epose proof (typing_canonical_record _ _ _ _ Typ (typ_box U1) _)
      as [BadTop | [[a [U2 BadRec]] | [a [U2 BadRec]]]]; try discriminate...
    unshelve epose proof (typing_canonical_record _ _ _ _ Typ (typ_mut mut_readonly (typ_box U1)) _)
      as [BadTop | [[a [U2 BadRec]] | [a [U2 BadRec]]]]; try discriminate...
  - inversion Val; inversion IntComp as [Prim Int]; eauto; subst...
    exfalso.
    unshelve epose proof (typing_canonical_record_rec _ _ _ _ H
      _ IntComp) as [BadTop | [a [U2 BadRec]]]; try discriminate.
  - exfalso.
    unshelve epose proof (typing_canonical_record_rec _ _ _ _ H
      _ IntComp) as [BadTop | [a [U2 BadRec]]]; try discriminate.
Qed.


Lemma canonical_form_readonly_ref : forall e R U1,
  value e ->
  typing empty R e (typ_mut mut_readonly (typ_box U1)) ->
  (exists l, e = exp_ref l) \/ (exists l, e = exp_seal (exp_ref l)).
Proof with eauto.
  intros e R U1 Val Typ.
  eapply canonical_form_readonly_ref_rec...
  right...
  exists (normal_form_typing U1)...
Qed.



Lemma value_record_comp_implies_record_comp : forall r,
  value_record_comp r ->
  record_comp r.
Proof with eauto.
  intros.
  induction H...
Qed.
#[export] Hint Resolve value_record_comp_implies_record_comp : core.

(** #<a name="lemma_4.5"></a># Lemma 4.5/4.10: Canonical forms for records.*)
Lemma canonical_form_record_rec : forall e a R T,
  value e ->
  typing empty R e T ->
  (exists U1, in_intersection_component (typ_record a U1) (normal_form_typing T)) ->
  exists l r, e = exp_record r /\ record_lookup_ref a r = Some l.
Proof with simpl in *; eauto; repeat fold merge_mutability in *; repeat fold normal_form_typing in*.
  intros e a R U1 Val Typ ExistsRecordType.
  dependent induction Typ;
    destruct ExistsRecordType as [U1 IntComp];
    try solve [inversion Val; inversion IntComp as [Prim Int]; inversion Int; eauto; try discriminate]...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int]...
    unshelve epose proof 
      (sub_inv_record empty _ a U1 T
       _ H0) as [[X IntX] | [S1 [IntS1 [SubL SubR]]]]...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
  - inversion Val; subst...
    inversion IntComp as [Prim Int]...
    exfalso...
    eapply merge_mutability_inversion_record_intersection in Int...

    inversion Val; subst...
    inversion IntComp as [Prim Int]...
    exfalso...
    eapply merge_mutability_inversion_record_intersection in Int...
  - inversion Val as [| | | |A ValRec|]; subst...
    inversion IntComp as [Prim Int]...
    induction H; subst; try discriminate...
    + inversion Int; subst; discriminate...
    + exfalso; inversion ValRec...
    + destruct (a0 === a); subst...
      * exists l; exists (rec_ref a l r)... split...
        destruct (a === a); intuition.
      * inversion Int as [|A B C Bad|]; subst; try discriminate...
        inversion Bad as [A B Eq | |]; inversion Eq; intuition...
        inversion ValRec; subst...
        destruct IHtyping_record_comp as [lRest [rRest [Eq Sel]]]...
        inversion Eq; subst...
        exists lRest; exists (rec_ref a0 l rRest); split...
        destruct (a === a0); intuition.
Qed.
Lemma canonical_form_record : forall e a R U1,
  value e ->
  typing empty R e (typ_record a U1) ->
  exists l r, e = exp_record r /\ record_lookup_ref a r = Some l.
Proof with eauto.
  intros e a R U1 Val Typ.
  eapply canonical_form_record_rec...
  exists (normal_form_typing U1)...
Qed.

(** #<a name="lemma_4.7"></a># Lemma 4.7: Canonical forms for read-only records.*)
Lemma canonical_form_readonly_record_rec : forall e a R T,
  value e ->
  typing empty R e T ->
  ((exists U1, in_intersection_component (typ_record a U1) (normal_form_typing T)) \/
   (exists U1, in_intersection_component (typ_mut mut_readonly (typ_record a U1))
     (normal_form_typing T))
  ) ->
  (exists l r, e = exp_record r /\ record_lookup_ref a r = Some l) \/ 
  (exists l r, e = exp_seal (exp_record r) /\ record_lookup_ref a r = Some l).
Proof with simpl in *; eauto 4; repeat fold merge_mutability in *; repeat fold normal_form_typing in*.
  intros e a R U1 Val Typ ExistsRecordTyp.
  dependent induction Typ;
    destruct ExistsRecordTyp as [[U1 IntComp] | [U1 IntComp]];
    try solve [inversion Val; inversion IntComp as [Prim Int]; inversion Int; eauto; try discriminate]...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int]...
    unshelve epose proof 
      (sub_inv_readonly_record empty _ a U1 T
       _ H0) as
       [[X IntX] | 
        [[X IntROX] |
         [[S1 [IntS1 SubL]] |
         [S1 [IntS1RO SubL]]]]]...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + left...
    + right...
  - assert (wf_typ empty S) as Contra1...
    apply IHTyp...
    inversion IntComp as [Prim Int]...
    unshelve epose proof 
      (sub_inv_readonly_record empty _ a U1 T
      _ H0) as
      [[X IntX] | 
        [[X IntROX] |
        [[S1 [IntS1 SubL]] |
        [S1 [IntS1RO SubL]]]]]...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + exfalso...
      assert (wf_typ empty X) as Contra3...
      inversion Contra3...
    + left...
    + right...
  - inversion Val; inversion IntComp as [Prim Int]; eauto; subst...
    exfalso.
    apply in_intersection_record_merge_in_normal in Int...
    unshelve epose proof (typing_canonical_ref _ _ _ _ Typ (typ_record a U1) _)
      as [BadTop | [[U2 BadEq] | [U2 BadEq]]]; try discriminate...
    exfalso; eapply merge_mutability_inversion_record_intersection...
  - inversion Val; inversion IntComp as [Prim Int]; eauto; subst...
    apply in_intersection_readonly_record_merge_in_normal in Int as [Int | IntRO]...
    unshelve epose proof (typing_canonical_ref _ _ _ _ Typ (typ_record a U1) _)
      as [BadTop | [[U2 BadRec] | [U2 BadRec]]]; try discriminate...
    unshelve epose proof (typing_canonical_ref _ _ _ _ Typ (typ_mut mut_readonly (typ_record a U1)) _)
      as [BadTop | [[U2 BadRec] | [U2 BadRec]]]; try discriminate...
    apply in_intersection_readonly_record_merge_in_normal in Int...
    destruct Int as [Int|Int]...
    + destruct IHTyp as [[l' [r' [Eq Sel]]] | [l' [r' [Eq Sel]]]]; subst...
      left; exists U1...
      * inversion Eq; subst...
        right...
      * inversion Eq; subst...
    +  destruct IHTyp as [[l' [r' [Eq Sel]]] | [l' [r' [Eq Sel]]]]; subst...
        right; exists U1...
      * inversion Eq; subst...
        right...
      * inversion Eq; subst...
  - inversion Val as [| | | |A ValRec|]; inversion IntComp as [Prim Int]; eauto; subst...
    induction H; subst; try discriminate...
    + inversion Int; subst; discriminate...
    + exfalso; inversion ValRec...
    + destruct (a0 === a); subst...
      * left; exists l; exists (rec_ref a l r)... split...
        destruct (a === a); intuition.
      * inversion Int as [|A B C Bad|]; subst; try discriminate...
        inversion Bad as [A B Eq | |]; inversion Eq; intuition...
        inversion ValRec; subst...
        destruct IHtyping_record_comp as [[lRest [rRest [Eq Sel]]] | [lRest [rRest [Eq Sel]]]]...
          inversion Eq; subst...
          left. exists lRest; exists (rec_ref a0 l rRest); split...
          destruct (a === a0); intuition.
          inversion Eq; subst...
  - inversion Val as [| | | |A ValRec|]; inversion IntComp as [Prim Int]; eauto; subst...
    induction H; subst; try discriminate...
    + inversion Int; subst; discriminate...
    + exfalso; inversion ValRec...
    + destruct (a0 === a); subst...
      * left; exists l; exists (rec_ref a l r)... split...
        destruct (a === a); intuition.
      * inversion Int as [|A B C Bad|]; subst; try discriminate...
        inversion Bad as [A B Eq | |]; inversion Eq; intuition...
        inversion ValRec; subst...
        destruct IHtyping_record_comp as [[lRest [rRest [Eq Sel]]] | [lRest [rRest [Eq Sel]]]]...
          inversion Eq; subst...
          left. exists lRest; exists (rec_ref a0 l rRest); split...
          destruct (a === a0); intuition.
          inversion Eq; subst...  
Qed.
Lemma canonical_form_readonly_record : forall e a R U1,
  value e ->
  typing empty R e (typ_mut mut_readonly (typ_record a U1)) ->
  (exists l r, e = exp_record r /\ record_lookup_ref a r = Some l)
    \/
  (exists l r, e = exp_seal (exp_record r) /\ record_lookup_ref a r = Some l).
Proof with eauto.
  intros e a R U1 Val Typ.
  eapply canonical_form_readonly_record_rec...
  right...
  exists (normal_form_typing U1)...
Qed.

Lemma typing_store_implies_wellformed_store : forall E R s,
  typing_store E R s ->
  well_formed_store s.
Proof with eauto; intuition.
  intros * Wf l v MapsTo.
  edestruct Wf with (l := l) as [Fwd Bk].
  edestruct (Bk v)...
Qed.
#[export] Hint Resolve typing_store_implies_wellformed_store : core.

(* ********************************************************************** *)
(** ** Progress (16) *)
Lemma progress : forall e s R T,
  typing empty R e T ->
  typing_store empty R s ->
  value e \/ exists e' s', red e s e' s'
with progress_record_comp : forall r s R T,
  typing_record_comp empty R r T ->
  typing_store empty R s ->
  value_record_comp r \/ exists r' s', red_record_comp r s r' s'.
Proof with eauto using sub_reflexivity.
------
  clear progress.
  intros e s R T Typ TypStore .
  remember empty as E in Typ, TypStore. generalize dependent HeqE.
  assert (Typ' : typing E R e T)...
  induction Typ; intros EQ; subst...
  Case "typing_var".
    inversion H1.
  Case "typing_app".
    right.
    destruct IHTyp1 as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct IHTyp2 as [Val2 | [e2' [s2' Rede2']]]...
      SSCase "Val2".
        destruct (canonical_form_abs _ _ _ _ Val1 Typ1) as [S [e3 EQ]].
        subst.
        exists (open_ee e3 e2)...
  Case "typing_tapp".
    right.
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct (canonical_form_tabs _ _ _ _ Val1 Typ) as [S [e3 EQ]].
      subst.
      exists (open_te e3 T)...
  Case "typing_let".
    right.
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    exists (open_ee e2 e1)...
  Case "typing_box".
    right.
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
  Case "typing_unbox".
    right.
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct (canonical_form_ref _ _ _ Val1 Typ) as [l EQ].
      subst.
      destruct (typing_inv_ref empty R l (typ_box T) Typ T) as [U [Sub1 [Sub2 Binds]]]...
      destruct (TypStore l) as [Fwd _].
      destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
  Case "typing_set_box".
    right.
    destruct IHTyp1 as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct IHTyp2 as [Val2 | [e2' [s2' Rede2']]]...
      SSCase "Val2".
        destruct (canonical_form_ref _ _ _ Val1 Typ1) as [l EQ].
        subst.
        destruct (typing_inv_ref empty R l (typ_box T) Typ1 T) as [U [Sub1 [Sub2 Binds]]]...
        destruct (TypStore l) as [Fwd _].
        destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
  Case "typing_seal".
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    inversion Val1; subst; try solve [right; eauto]; try solve [left; eauto].
  Case "typing_unbox_sealed_ref".
    right.
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct (canonical_form_readonly_ref _ _ _ Val1 Typ) as [[l Ref] | [l SealedRef]]; subst...
        SSCase "readonly_ref".
          destruct (typing_inv_readonly_ref empty R l _ Typ T) as [U [Sub1 [Sub2 Binds]]]...
          destruct (TypStore l) as [Fwd _].
          destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
        SSCase "sealed_readonly_ref".
          destruct (typing_inv_sealed_readonly_ref empty _ _ _ Typ T) as [U [Sub1 [Sub2 Binds]]]...
          destruct (TypStore l) as [Fwd _].
          destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
  Case "typing_record".
    unshelve epose proof (progress_record_comp _ _ _ _ H TypStore)
      as [ValueRec | [r' [s' Redr']]]...
  Case "typing_record_read".
    right. 
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct (canonical_form_record _ a _ _ Val1 Typ)
        as [l [r [Eq Sel]]]; subst; simpl in *...
      inversion Val1; subst...
      destruct (typing_inv_record empty R r a l (typ_record a T) Typ Sel T) as [U [Sub1 [Sub2 Binds]]]...
      destruct (TypStore l) as [Fwd _].
      destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
  Case "typing_record_readonly_read".
    right.
    destruct IHTyp as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct (canonical_form_readonly_record _ a _ _ Val1 Typ)
        as [[l [r [Eq Sel]]] | [l [r [Eq Sel]]]]; subst; simpl in *...
      SSCase "readonly_record".
        inversion Val1; subst...
        destruct (typing_inv_readonly_record empty R r a l (typ_mut mut_readonly (typ_record a T)) Typ Sel T) as [U [Sub1 Binds]]...
        destruct (TypStore l) as [Fwd _].
        destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
      SSCase "sealed_readonly_record".
        inversion Val1; subst...
        destruct (typing_inv_sealed_readonly_record empty R r a l (typ_mut mut_readonly (typ_record a T)) Typ Sel T) as [U [Sub1 Binds]]...
        destruct (TypStore l) as [Fwd _].
        destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
  Case "typing_record_write".
    right.
    destruct IHTyp1 as [Val1 | [e1' [s1' Rede1']]]...
    SCase "Val1".
      destruct IHTyp2 as [Val2 | [e2' [s2' Rede2']]]...
      SSCase "Val2".
        destruct (canonical_form_record _ a _ _ Val1 Typ1)
          as [l [r [Eq Sel]]]; subst; simpl in *...
        inversion Val1; subst...
        destruct (typing_inv_record empty R r a l (typ_record a T) Typ1 Sel T) as [U [Sub1 [Sub2 Binds]]]...
        destruct (TypStore l) as [Fwd _].
        destruct (Fwd U) as [v [MapsTo [TypingV ValueV]]]...
------
  clear progress_record_comp.
  intros r s R T Typ TypStore.
  remember empty as E in Typ, TypStore. generalize dependent HeqE.
  assert (Typ' : typing_record_comp E R r T)...
  induction Typ; intros EQ; subst...

  Case "typing_record_empty".
    destruct (progress e s R T H0 TypStore) as [Vale | [e' [s1'' Rede']]]...
    right...
  Case "Redr1".
    destruct IHTyp as [Val1 | [r1' [s1' Redr1']]]...
Qed.
